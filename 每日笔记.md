# 线程

## 1.线程创建方式

### 1.1继承Thread类

* 创建一个类继承Thread并且重写run()方法

```java
package com.itheima.thread_01;

public class PrimeThread extends Thread{
//    1. 创建一个类继承Thread
//    2. 重写run方法


    @Override
    public void run() {
        //线程中需要执行的代码
        //fori(单纯的循环) itar 普通遍历方式 iter 增强for循环
        for (int i = 0; i < 10; i++) {
            System.out.println("我是子线程" + i);
        }
    }
}
```

```java
package com.itheima.thread_01;

public class PrimeDemo {
    public static void main(String[] args) {
        //    3. 创建子类对象
        PrimeThread t1 = new PrimeThread();
        //    4. 调用方法启动线程
        //t1.run();
        t1.start();
        for (int i = 0; i < 10; i++) {
            System.out.println("我是main方法" + i);
        }
    }
}

```

### 1.2实现Runnable接口

步骤:

1. 创建一个类实现Runnable接口
2. 实现run方法
3. 创建Runnable实现类的对象
4. 将实现类对象作为参数创建Thread对象
5. 调用start方法启动线程

```java
package com.itheima.thread_02;

public class PrimRun implements Runnable {
    //1. 创建一个类实现Runnable接口
//2. 实现run方法
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println("子线程" + i);
        }
    }
}
```

```java
package com.itheima.thread_02;

public class PrimDemo {
    public static void main(String[] args) {
        //3. 创建Runnable实现类的对象
        PrimRun primRun = new PrimRun();
        //4. 将实现类对象作为参数创建Thread对象
        Thread t1 = new Thread(primRun);
        //5. 调用start方法启动线程
        t1.start();

        Thread t2 = new Thread(primRun);
        t2.start();
    }
}
```

## 2.线程休眠

 Thread.sleep(毫秒)

```java
package com.itheima.thread_03;

public class ThreadDemo {
    public static void main(String[] args) throws InterruptedException {
        //System.out.println(Thread.currentThread().getName());
        for (int i = 0; i < 10; i++) {
            Thread.sleep(1000);
            System.out.println(i);
        }
    }
}

```

## 3.线程安全问题

造成原因：多个线程共同争抢一个资源

解决方法：同步代码块

```text
synchronized( 需要一个任意的对象（锁）)
    {
         代码块中放操作共享数据的代码。
    }
锁可以是任意对象。Object obj=new Object(); 
```

```java
package com.itheima.ticket;
/*
多个窗口在售电影票
假设  总票数为100张
三个售票窗口
每一个窗口都有一百张票 还是 三个窗口共同销售100张票
 */
public class TicketThread extends Thread{
    //被static修饰的属性 被所有的对象共享
    private static int tickets = 100;
    //锁对象唯一  保证被所有的线程共享
    private static Object lock = new Object();
    @Override
    public void run() {
        //完成卖票功能
        while(true) {
            synchronized (lock) {
                if (tickets > 0) {
//                try {
//                    Thread.sleep(100);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
                    System.out.println(getName() + "正在出售第" + tickets + "张票");
                    tickets--;
                } else {
                    break;
                }
            }
        }
    }
}

```

## 4.线程池

线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。

使用线程池中线程对象的步骤：

​	A：自定义一个类，作为任务类并实现Runnable接口；

​	B：实现Runnable接口中的run方法；

​	C：创建任务类的对象；

​	D：获取线程池对象；

​	E：直接执行任务；

### 用线程池执行卖票程序

需求：使用线程池来完成卖票任务。

Runnable实现类代码：

```java
package com.itheima;
//A:自定义一个类，作为任务类并实现Runnable接口；
class SellTicketTask implements Runnable {
    //定义成员变量存储100张票
    private static int tickets = 100;
    //B:实现Runnable接口中的run方法；
    public void run() {
        // 模拟卖票
        while (true) {
            //锁
            synchronized (this) {
                if (tickets > 0) {
                    //休眠
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                    }
                    System.out.println(Thread.currentThread().getName() + "出票：" + tickets);
                    tickets--;
                }
            }
        }
    }
}
```

线程池测试类：

```java
package com.itheima;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class SellTicketDemo {
    public static void main(String[] args) {
        //C:创建任务类的对象；
        SellTicketTask stt = new SellTicketTask();
        //D:获取线程池对象； 获取2个线程
        ExecutorService es = Executors.newFixedThreadPool(2);
        //E:直接执行任务；
        //自己创建线程对象的方式
        // Thread t = new Thread(stt);
        // t.start(); ---> 调用MyRunnable中的run()

        // 从线程池中获取线程对象,然后调用SellTicketTask中的run()
        es.execute(stt);
        // 再获取个线程对象，调用SellTicketTask中的run()
        es.execute(stt);
    }
}

```



## 

# 反射

1.什么是反射，原理

 反射的原理：从类的字节码文件中获取成员变量，成员方法和构造方法。

## 1.获取字节码对象

1.对象.getClass()

2.类名.Class

3.Class.forName(包名和类名)   --------------- **常用**

```java
 //1-获取字节码对象
        //第一种方法通过.getClass
        Student stu = new Student();
        Class<? > claszz1 = stu.getClass();

        //第二种，  通过类名.class
        Class<?> clazz2 = Student.class;

        //第三种  Class.forName
        Class<?> clazz3 = Class.forName("reflect.Student");
```

## 2.用反射创建对象

**getConstructor方法**

**私有构造需暴力访问：setAccessible（true）**

```java
//第三种  Class.forName
Class<?> clazz3 = Class.forName("reflect.Student");

//2-通过getConstructor() 获取公共构造方法
Constructor<?> constructor = clazz3.getConstructor(String.class, int.class, String.class);

//3-通过newInstance() 创建对象
Object stud = constructor.newInstance("刘能",25,"男");


//通过getDeclaredConstructor获取私有构造方法
Constructor<?> declaredConstructor = clazz3.getDeclaredConstructor(String.class, int.class);
declaredConstructor.setAccessible(true);
Object stud2 = declaredConstructor.newInstance("赵四",25);
```

## 3.用反射调用属性字段

**getField**

**私有构造需暴力访问：setAccessible（true）**

```java
//创建字节码对象
Class<?> clazz = Class.forName("reflect.Student");
//创建对象
Object stu = clazz.newInstance();
//获取name字段
Field nameField = clazz.getDeclaredField("name");
nameField.setAccessible(true);
nameField.set(stu,"李四");
Object name = nameField.get(stu);
System.out.println(name);
```

## 4.用反射调用方法

**getMethod**

**私有构造需暴力访问：setAccessible（true）**

```java
//创建字节码对象
Class<?> clazz = Class.forName("reflect.Student");
//用字节码对象创建实例
Object stu = clazz.newInstance();
//
Method getSumMethod = clazz.getDeclaredMethod("getSum", int.class);
getSumMethod.setAccessible(true);
Object sum = getSumMethod.invoke(stu, 20);
System.out.println(sum);
```



## 5.反射创建类实例三种方法

### 5.1调用类的Class对象的newInstance方法

````java
Class<?> clazz = ExtendType.class;
Object inst = clazz.newInstance();
````

### 5.2调用默认Constructor对象的newInstance方法

```java
Class<?> clazz = ExtendType.class;
Constructor<?> cons=clazz.getConstructor();
Object inst = cons.newInstance();
```

### 5.3调用带参构造的newInstance方法

```java
Class<?> clazz = ExtendType.class;
Constructor<?> cons=clazz.getConstructor(int.class,String.class);
Object inst = cons.newInstance(1,"silly");
```







# Mysql数据库操作

## 1.1 DDL （数据定义语言）

数据定义语言 - Data Definition Language

用来定义数据库的对象，如数据表

create drop alter truncate(清空数据记录)等

### 1.1.1查询当前所有数据库

语法：show databases;

![1562044224986](assets/1562044224986.png)

### 1.1.2查看当前数据库的创建方式：查看数据库的编码表。

语法：show create database 库名;

![1561722992783](assets/1562044238109.png)

### 1.1.2创建一个使用utf8字符集的mydb2数据库。

语法：create database 库名 character set 字符集

![1561723072103](assets/1562044259182.png)

### 1.1.3删除数据库

语法：drop database 数据库名;

![1561723219611](assets/1562044275791.png)

### 1.1.4修改数据库编码集

语法：alter database 数据库名称 character set 字符集；

![1561723311421](assets/1562044285498.png)

### 1.1.5切换数据库

语法：use 库名；

![1561723353274](C:\Users\94928\AppData\Local\Temp\1561723353274.png)



### 1.1.6查询当前正在使用的数据库

语法：select database();

![1561723445344](assets/1562044293344.png)

### 1.1.7创建表

**创建表之前一定要先选择仓**

语法：create table 表名(

​	列名 类型(长度)，

​	......

​	列名 类型(长度)

);

![1561723702699](assets/1562044308289.png)

### 1.1.8查看数据库中所有的表

语句：show tables;

![1561723877658](assets/1562044314853.png)

### 1.1.9查看表结构信息

语法：desc 表名；

![1561724006468](assets/1562044320322.png)

### 1.1.10单表创建时约束

语法：1>主键约束：primary key    自增长 auto_increment

​	2>唯一约束：unique

​	3>非空约束：not null

建表结构：

![1561728094124](assets/1562044333351.png)

查看数据库的表：

![1561728142283](assets/1562044338733.png)

查看表结构：

![1561728098810](assets/1562044343770.png)

### 1.1.11. 数据表结构修改，对表名，列名，列的类型进行修改

语法：**alter table 表名 增/删/改 列名 类型(长度) 约束；**

#### **1.增加列名  add **

**** alter table emp2 add salary double；****

![1561728657964](assets/1562044358594.png)

#### **2.修改现有列 modify  **

alter table emp2 modify birthday date not null;

![1561728664333](assets/1562044382306.png)

#### **3.修改现有列名称 change**

语法：alter table 表名 change 旧列名 新列名 类型(长度) 约束;

alter table emp2 **change** name username varchar(60) unique not null;

![1561728729005](assets/1562044390319.png)

#### **4.删除现有列  drop**

alter table emp2 drop age;

![1562044399882](assets/1562044399882.png)

#### **5.修改表名  rename**

语法： rename table 旧表名 to 新表名;

rename table emp2 to person;

![1562044414365](assets/1562044414365.png)

#### **6.修改表的字符集**

语法：alter table 表名 character set 编码集;

alter table emp character set utf8;

#### **7.数据表删除**

语法：drop table 表名；

### 1.1.12truncate 语句----删除数据

truncate table 表名： 

先删除表,再创建表，就等于将数据全部删除了。也就是说上述语句执行时会把表的所有内容都删除掉，然后在创建一个新的表。

性能问题： truncate table的性能相对来说更好，尤其删除的数据越多，越明显。

练习1：向person表中插入数据，然后使用：truncate table 表名。 来删除所有的数据。

插入语句：

![img](file:///C:\Users\94928\AppData\Local\Temp\ksohtml11640\wps3.jpg) 

 

删除语句：

![img](file:///C:\Users\94928\AppData\Local\Temp\ksohtml11640\wps4.jpg) 

 

如果要删除一张表中的所有数据，也可以使用 **truncate table 表名;**

执行时会把表的所有内容都删除掉，然后在创建一个新的表。

**truncate 缺点：不能有条件的删除。不能恢复数据**

delete 是逐行删除，并没有恢复初始化值。 可以恢复数据

## 1.2 DML  （数据操纵语言）★★★ -- 增删改(表记录)

数据处理语言 - Data Manipulation Language

在数据库表中更新，增加和删除记录

如 **update(更新)， insert(插入)， delete(删除)** 不包含查询

### 1.2.1  insert语句----向数据表插入数据

语法：insert into 表名 (列名1，列名2，列名3......)  values (值1，值2，值3......);

语法：insert into 表名 values (值1，值2，值3......);

语法：insert into 表名 values (值1，值2，值3......),(值1，值2，值3......),(值1，值2，值3......)....;

**注意事项：**

**1、值与列一一对应。有多少个列，就需要写多少个值。如果某一个列没有值。可以使用null。表示插入空。**

**2、值的数据类型，与列被定义的数据类型要相匹配。并且值的长度，不能够超过定义的列的长度。**

**3、字符串：插入字符类型的数据，建议写英文单引号括起来。在mysql中，使用单引号表示字符串。**

**4、date 时间类型的数据也得使用英文单引号括起来： 如’yyyy-MM-dd’,’yyyy/MM/dd’,’yyyyMMdd’ 。**

**5、如果主键是自动增长的，可以直接插入数值null。**

#### 方式一：全写

 insert into person values(null,'zhangsan','123','nan','1992-8-19',12000);

![1561730007384](assets/1562044473666.png)

#### 方式二：省略部分

注意：在插入数据的时候，如果某些列可以为null，或者是自动增长的列，或者有默认值的，在插入的时候可以省略。

insert into person(username,password,birthday) values('suoge','123','1995-10-19');

![1562044573082](assets/1562044573082.png)



#### 方式三：一次插入多行数据

insert into 表名 values（值，值，值，值）,（值，值，值，值）...；

![1561808917704](assets/1562044515813.png)

### 1.2.2 update语句---数据记录修改操作

语法：update 表名 set 列名=值，列名=值....  where 条件语句；

注意事项：

1、如果不加条件语句，将会修改某一列的所有值。

2、一般修改数据时，都需要增加条件。（重点）

update person set password='abcdef';

![1561814363792](assets/1562044603640.png)

update person set salary=88888 where username='zhangsan';

![1561814400033](assets/1562044611146.png)

### 1.2.3delete语句-----删除表中数据的语句

语法：delete from 表名 [where条件语句]

**注意：**

**1）如果删除表中的记录时，没有添加where条件，这时会把表中的所有数据删除。表依然存在，是空的表。**

**2）delete是删除行的数据。**

练习1：删除person表中username为zhaoliu的用户记录。

删除语句： delete from person where username='zhaoliu';

![1561815899210](assets/1562044640717.png)

练习2：删除表中所有记录。

删除语句：delete from person;

![img](assets/1562044652226.png) 

练习3：向person表中在添加一个新的数据。

插入语句：insert into person(username,password,birthday) values('tianqi','123','1990-9-7');

![img](assets/1562044667157.png) 

问题：我们发现使用delete语句将数据库表中所有的数据删除之后，在新添加的数据之后，id是在原来基础上继续递增，而不是1。那么我们想让新添加的数据id从1开始，怎么办呢？

### 1.2.4truncate 语句----删除数据

truncate table 表名： 

先删除表,再创建表，就等于将数据全部删除了。也就是说上述语句执行时会把表的所有内容都删除掉，然后在创建一个新的表。

性能问题： truncate table的性能相对来说更好，尤其删除的数据越多，越明显。

练习1：向person表中插入数据，然后使用：truncate table 表名。 来删除所有的数据。

插入语句：

![img](assets/1562044694683.png) 

 

删除语句：

![img](assets/1562044702890.png) 

 

如果要删除一张表中的所有数据，也可以使用 **truncate table 表名;**

执行时会把表的所有内容都删除掉，然后在创建一个新的表。

**truncate 缺点：不能有条件的删除。不能恢复数据**

delete 是逐行删除，并没有恢复初始化值。 可以恢复数据

**delete 和 truncate的区别**

- 1.DELETE
  ・DML语言
- ・数据还可以找回来，恢复回来
- 逐条删除 删除速度要慢一些
  ・可以有条件的删除。DELETE FROM 表名 WHERE 条件
  2.TRUNCATE TABLE
  ・DDL语言
- ・数据不可以恢复
  ・先将整个表删除，再重新创建
- ・删除速度比delete快。



## 1.3 DCL （数据控制语言）DBA(数据库管理员)

数据控制语言 – Data Control Language

指用于设置用户权限 -- DBA

如grant(设置权限)，revoke(撤销权限)，

## 1.4 TCL(数据操纵语言)(事务) begin transaction等

开发自然形成

## 1.5 DQL （数据查询语言）（★★★★★） - 查询

数据查询语言 – Data Query Language 

数据表记录的查询。

**select**。。。



### 1.5.1语法一：查询数据库中的某张表的所有数据

语法：select * from 表名;

表示查询表的所有信息。会把表的所有的列，所有的行都列出来。

1）select 表示选择的意思；

2）* 表示所有的数据；

3）from 表示从哪个表中选择；

![1561817179989](assets/1562044740784.png)

### 1.5.2语法二: 查询某张表中指定的列

语法： select 列名,列名...  from 表名;

说明：显示指定列数据。列出所有行信息。

需求：查询所有学生的姓名和成绩。

![1561817187348](assets/1562044757634.png)

### 1.5.3语法三：按条件查询

语法：select 列名,列名..... from 表名  where 条件;

说明：查找符合where条件的数据。

作用：过滤，只有符合条件的，才去列出相应的信息。

需求：查询表中年龄大于等于24岁的学生信息。

![1562044776027](assets/1562044776027.png)

### 1.5.4运算符：

1) >(大于)  <(小于)  >=(大于等于)  <=(小于等于)  =(相等)  <>或者!= (不相等) 

需求：查询年龄不是25岁的学生。

![img](assets/1562044788543.png) 

2） 

and 逻辑与 ，多个条件同时成立。&&

or 逻辑或 ，多个条件任意一个成立。||

not 逻辑非 ，相反的意思。!

需求一：查询年龄>23，并且成绩>80的同学信息。

![img](assets/1562044795634.png) 

 

需求二：查询成绩在80~100(包含)之间的学生信息。

![img](assets/1562044808402.png) 

3）区间：between  ...  and ... 在两者之间取值。  格式：列名 between 开始值 and 结束值;

注意：前面那个数即开始值要比后面那个数即结束值要小 。

例如：between 70 and 80 在70和80之间。

​    等价于 >=70  and  <=80    

age >=24 and age<=50 等价于 age between 24 and 50

原理说明图：

![img](assets/1562044820168.png) 

需求：查询成绩在80~100(包含)之间的学生信息。

![img](assets/1562044832116.png) 

4）in(值1,值2,值3) 在指定值中任意取。

 举例： in(70,80,90) 值可以是70、80或者90 

 使用格式：

where 列名 in (值，值，值.......);

等价于

where 列名=值 or 列名=值 or 列名=值 .......

需求：查询年龄为18，23，25的同学信息。

![img](assets/1562044841062.png) 

5）模糊查询：like '模糊查询部分'

 表达式有两个占位符：

A:  % 表示零或任意多个字符 ;

B:  _ 任意单个字符;

例如：  name like '张%' 所有姓张学员。 

name like '%张%' 只要有张就可以。

name like '张_' 所有姓张名字为两个字学员。

name like '_张_'  只有中间是张，前面一个字，后面一个字。

需求：查询所有含有 岩 的学生信息。

![img](assets/1562044850711.png) 

注意：含有某个值:  %xx%

6）is null 判断该列值是否为空。

sql中对null的判断，不能写 = null   在sql 中 null = null 结果不成立。 正确格式：is null

不是空 ： is not null。

需求1：查询没有生日学员信息。就是生日是null。

![img](assets/1562044860482.png) 

需求2：查询有年龄学员信息。就是年龄不是空。

![img](assets/1562044864560.png) 



### 1.5.5语法四 ：过滤重复数据：

查询排重：select distinct 列名,列名... from 表名 [where 条件];

说明：distinct： 去重复。显示distinct后面列的内容，并且过滤掉重复的数据。

需求：显示不重复的年龄。

![img](assets/1562044873371.png) 

###  1.5.6语法五 ：对查询的结果进行排序：

使用order by 子句排序查询结果。

**语法：select \* from 表名 order by 列名1  asc|desc，列名2（asc|desc），列名3（asc|desc） 。。。。。;**

按照列名1，列名2，列名3 进行排序输出。

asc是升序排列，desc是降序排列。默认是asc升序

按照第一列进行排序，如果第一列相同，按照第二列在进行排序。

注意： order by a asc,b  asc

​		a, b              

​		1, 2

​		1, 3

​		4, 5

​		3, 1

结果：

​       1,2

​       1,3

​       3,1

​       4,5

需求：

1、对成绩排序后输出。

2、对年龄排序按从高到低（降序）的顺序输出。

3、对学生年龄按照降序排序，年龄相同按照成绩降序。

1、对成绩排序后输出。

​	![img](assets/1562044891469.png)



2、对年龄排序按从高到低（降序）的顺序输出。

 

 ![1562044897100](assets/1562044897100.png)

3、对学生年龄按照降序排序，年龄相同按照成绩降序。

![img](assets/1562044908760.png) 

### 1.5.7别名：可以对查询出来的列名起别名

语法：select 列名 as 别名,列名 as 别名,列名 as 别名.... from 表名 where 条件;

注意：在使用别名的时候，as 关键字可以省略。

需求1、给年龄和分数起别名。

![img](assets/1562044920297.png) 

 

需求2、省略关键as 再次查询。

![img](assets/1562044932052.png) 

  **面试题：**

**1、select age , score from student;**

**2、select age score from student;**

**上述SQL语句有什么区别？**

**第一个Sql语句查询结果如下图所示：**

![img](assets/1562044947178.png) 

**查询结果有两列，分别是age和score。**

**第二个Sql语句查询结果如下图所示：**

![img](assets/1562044958425.png) 

**查询结果只有一列，其实显示的数据是age列，数据上面的名字是别名score。**

### 1.5.8count函数--统计记录数(统计行数)

**语法：select count(\*)或者count(具体列名) from 表名;**

**注意：** 

1、count(具体列名)：在根据指定的列统计的时候，如果这一列中有null的行，该行 不会被统计在其中。按照列去统计有多少行数据。

2、

select count(列名) from 表名:按具体列来进行统计行数。

select count(*) from 表名: 统计表中的行数。

1、统计一个班级共有多少学生？

![img](assets/1562044970685.png) 

![img](assets/1562044985619.png) 

 

2、统计成绩大于80的学生有多少个？

 

![img](assets/1562044992508.png) 

### 1.5.9 sum函数：求和

**语法：select sum(列名) ,sum(列名) ,......from 表名;** 

注意事项：

1、如果使用sum 多列进行求和的时候，如果某一列中含有null，这一列所在的行中的其他数据不会被加到总和中。

需求：

统计一个班级成绩和。

![img](assets/1562045000223.png) 

2、分别统计年龄和, 成绩和。

![img](assets/1562045005570.png) 

3、统计年龄与成绩的总和值。

方法一：

![img](assets/1562045011816.png) 

方法二：

![img](assets/1562045021268.png) 

表中的所有数据：

![img](assets/1562045026751.png) 

我们发现按照方法二的做法，结果是有问题的。结果少了84。

产生问题的原因：

上述写法会先将每一行的年龄值和分数值进行相加，然后再把每一行的年龄值和分数值相加后的值进行求和。

​	这样写会出现一个问题，因为在mysql中null值和任何值相加为null,导致在进行柳岩的年龄和分数相加的时候，柳岩的年龄和分数和值就变为了null。而最后sum求和的时候，就把柳岩的年龄和分数和值null给排除，因此最后的和值会缺少柳岩的年龄和分数和值84。

 

解决方案：在sql语句中我们可以使用数据库提供的函数ifnull(列名, 默认值)来解决上述问题。

**ifnull(列名, 默认值)函数表示判断该列名是否为null,如果为null，返回默认值，如果不为null，返回实际的值。**

例子：

age 的值是null

​	ifnull(age,2) ====age列的值是null，返回值是 2

age 的值是3

​    ifnull(age,2) ===== age列的值不是null，返回实际值是3

 

![img](assets/1562045039853.png) 

关于上述结果仍然有一个小的问题，就是小数点后面的内容比较多，如果我们希望保留具体的几位小数，我们可以使用

**数据库中的函数：truncate(列名, 截取的小数位) 表示截取的意思，保留几位小数。**

具体做法如下所示：

 

![img](assets/1562045048519.png) 

select truncate(sum(ifnull(age,0) + ifnull(score, 0)),2) from student;

### 1.5.10avg函数：求平均值

**语法： select avg(列名) from 表名;**

**注意：**求某列的平均值，avg里面的null不作为统计。

需求：求一个班级平均年龄。

 

![img](assets/1562045065867.png)

### 1.5.11 max，min函数：最大最小值

max(列) /min(列)  统计该列的最大值或者最小值。

select max(列名),min(列名) from 表名;

注意：null 排除在外。

需求：求班级最高分和最低分。

 

![img](assets/1562045075460.png)

### 1.5.12group by分组函数（★★★★★） 

官方定义：

分组： 按照某一列或者某几列。把相同的数据，进行合并输出。

完整写法：

select … from … group by 列名，列名

按照某一列进行分组：

目的：仍然是统计使用。

分组生活举例：假设去超市买东西，我买了肥皂、洗衣粉、洗衣液、苹果、香蕉、葡萄等。我们在计算总价格之前先对所买的商品进行分类计算价格，然后在相加计算总价格。比如我们先将肥皂、洗衣粉、洗衣液分为一组计算出价格，然后再将苹果、香蕉、葡萄分为一组计算出价格，最后将两组的价格相加就是商品的总价格。

 

说明：分组其实就是按列进行分类，然后可以对分类完的数据使用聚合函数进行运算。

![img](assets/1562045084502.png) 

上述数据表示纸巾和洗衣粉属于不同品牌，但是价格是一样的。

 

注意：

1、聚合函数：分组之后进行计算；

2、通常 select后面的内容是被分组的列，以及聚合函数； 

需求1：查询购买的每种商品的总价。

分析：

查询的内容：product,sum(price) 按照商品名称进行分类。

按照商品分组，应该分成如下几组数据：

![img](assets/1562045108961.png) 

分组之后查询的结果应该是：

洗衣粉  120

红牛    5

纸巾    32

苹果    8

最终答案：

![img](assets/1562045115000.png) 

说明：先按照product进行分组，分组完成之后再给每一组进行求和。

注意：分组有一个特点：

一旦使用了分组函数，那么最终在显示的时候，只能显示被分组的列或者聚合函数。

举例：修改上述的查询语句：查询结果添加一个id。

select id,product,sum(price) from orders group by product;

结果如下所示：

![img](assets/1562045128832.png) 

原来的数据：

![img](assets/1562045138471.png) 

说明：

通过查询的结果和原来的数据比较发现，虽然添加id之后可以查询出结果，但是对于纸巾商品来说有问题，查询结果显示id是1，而纸巾的结果的id除了1还有2，同是纸巾，牌子还不一样，所以查询结果有问题。

 

修改上述数据库表中的数据：

将纸巾id为2的price价格修改为20。

![img](assets/1562045151161.png) 

然后修改查询语句，要求是先按照商品名分组，然后在按照价格进行分组。

![img](assets/1562045158723.png) 

出现上述结果的原因是：

![img](assets/1562045166169.png) 

以上结果说明：先按照商品名字进行分组，然后再按照商品的价格进行分组。

如果使用多个字段  两个字段都会起到作用

需求2：查询每一种商品的总价大于30的商品，并显示总价。

分析：

显示商品和总价，要求条件是商品的总价大于30的商品。

书写的sql语句如下所示：

![img](assets/1562045176511.png) 

可是执行上述sql语句时，会报如下错误：

![img](assets/1562045183015.png) 

是因为上述的sql语句的使用有错误。

主要原因：在sql语句中的where 后面不允许添加聚合函数，添加就会报上述错误。

那么既然这里不能使用where来解决问题，但是我们还依然要进行过滤，所以在sql语句中，如果分组之后，还需要一些条件。

可以使用having条件，表示分组之后的条件，在having后面可以书写聚合函数。

关于 having 的用法解释：

having和group by 一起使用，having和where的用法一模一样，where怎么使用having就怎么使用，where不能使用的，having也可以使用，比如说where后面不可以使用聚合函数，但是在having后面是可以使用聚合函数的。

 

修改后的sql语句如下所示：

![img](assets/1562045191792.png) 

 

关于以上sql语句可以实现的最终结果的原因如下所示：

![img](assets/1562045202531.png) 

总结：

一、关于group by 和having一起使用的规则如下所示	

group by 列名 having 条件 

分组之后加过滤条件。

现在 我们学习过的sql语句有很多,那么我们一起为这些语句的顺序排个序.

**S(select)****…** **查询**

**F(from)****…** **从哪个表中**

**W(where)****…** **关联一些条件**

**G(group by)****…** **分组查询**

**H(having)****…** **关联一些条件(还可以关联聚合函数)**

**O(order by);** **排序 asc升序 desc 降序**

**S(select)** **查询的字段** **F(from)** **tablename** **W(where)** **关联条件** **G(group by)** **分组的字段** **H(having)** **关联条件(聚合函数)****O(order by)** **(asc desc)****;**

 

二、where 和 having 的区别。

1、having 通常与group by 分组结合使用。 where 和分组无关。

 

2、having是否可以替换之前的where呢？

![img](assets/1562045221560.png) 

答案是可以的，但是会有一些要求。

解释：上面的having可以用的前提是我已经筛选出了price字段，在这种情况下和where的效果是等效的，但是如果我没有select price 就会报错！！

(注意：这里书写 * 就表示筛选出来的包括price 字段。)

因为having是从筛选出来的字段再筛选，而where是从数据表中的字段直接进行的筛选的。

进一步解释上述说法：

使用where就可以查询出结果。

![img](assets/1562045228801.png) 

但是使用having就会报错。

![img](assets/1562045235459.png) 

因为前面的select product,id ，并没有筛选出price。所以会报错。

总结：开发中建议上述情况下使用where，避免没有必要的错误。

 

3、where 后面的条件可以写在having 中，但是 having中的条件不一定能写在where中。

having 可以书写聚合函数 (聚合函数出现的位置： having 之后)

  例如having中的 聚合函数（count，sum，avg，max，min），是不可以出现where条件中。

 

4、where 是在分组之前进行过滤的。having 是在分组之后进行过滤的。

sql语句举例：

![img](assets/1562045246724.png) 

上述sql语句执行顺序如下图所示：

![img](assets/1562045253218.png) 

 

select ... from ... where 条件1 ... gropu by ... having 条件2

执行顺序：

条件1 会先执行过滤

进行分组

条件2进行过滤

###  1.5.13查询关键字执行流程

select …要显示的内容.. from …表名.. where  条件…. group by …分组的列 …having …分组后的条件… order by …排序

查询语句可以省略 但是顺序不能变 比如 将分组省略 having 跟在 where后面

select …5… from …1..  where …2.. group by ..3…having ..4… order by .6.

查询的执行顺序：

**1）**from : 表名    

**2）**where：条件过滤

**3）**group by : 分组

**4）**having ： 分组之后进行过滤。

**5）**select ：执行完毕之后，显示内容。

**6）**order by ： 根据查询的内容进行排序输出.



# 数据库多表

## 添加外键约束

### 方式一：给已存在的表添加外键约束

```mysql
alter table coder_project add foreign key(coder_id) references coder(id);
alter table coder project add foreign key(project_id) references project(id);
```

### 方式二：创建表时添加外键约束

```mysql
create table coder_project{
	coder_id int;
	project_id int;
	foreign key(coder_id) references coder(id),
	foreign key(project_id) references project(id)
}
```

## 一对多关系

作者和小说，用户和订单的关系等....

![1563672654634](assets/1563672654634.png)

## 多表查询

~~~mysql
create table A(
  id int primary key auto_increment,
  name varchar(20) not null
);
insert into A values(1,'苹果');
insert into A values(2,'橘子');
insert into A values(3,'香蕉');

create table B( 
   id int primary key auto_increment,
   price double
);
insert into B values(1,2.30);
insert into B values(2,3.50);
insert into B values(4,null);
~~~

### 1.交叉连接查询

select * from a,b;

select * from a cross join b;

![1563673125693](assets/1563673125693.png)

![1563673140976](assets/1563673140976.png)

### 2.内连接查询

![1563673383499](assets/1563673383499.png)

* 隐式内连接：select * from a,b where a.列名=b.列名;

  ![1563673344945](assets/1563673344945.png)

* 显示内连接：select * from 表名1  inner join 表名2 on 条件;

![1563673350066](assets/1563673350066.png)

### 3.左外连接查询

![1563673394812](assets/1563673394812.png)

语法：select * from 表1 left outer join 表2 on 条件;

举例：select * from a left outer join b on a.id = b.id;

说明：把left 关键字之前的表，是定义为左侧。 left关键字之后的表，定义右侧。查询的内容，以左侧的表为主，如果左侧有数据，右侧没有对应的数据，仍然会把左侧数据进行显示。

![1563673648801](assets/1563673648801.png)

### 4.右外连接查询

![1563673701270](assets/1563673701270.png)

语法：select * from 表1 right outer join 表2 on 条件;

举例：select * from  a  right  outer  join  b  on  a.id = b.id;

说明：如果右侧有数据，左侧没匹配到，把右侧的数据显示出来。right之前的是左侧，right之后的是右侧。

![1563673748135](assets/1563673748135.png)

### 5.子查询

把一个sql的查询结果作为另一个查询的参数

类似于java中链式编程

## SQL关联子查询

### 1.in

in 表示条件应该是在多个列值中。

in：使用在where后面，经常表示是一个列表中的数据，只要被查询的数据在这个列表中存在即可。

select * from student where id in (2,6,5)

### 2.all

![1563674174036](assets/1563674174036.png)

### 3.any&some

![1563674382657](assets/1563674382657.png)

### 4.as

as做一个别名 可以通过别名.属性   表名.属性  将查询结果作为中间表查询

![1563674664631](assets/1563674664631.png)

### 5.limit

语法：select * from 表名 limit offset,row_count

offset:表示起始索引  从0开始

row_count:表示查询记录数

![1563674900406](assets/1563674900406.png)



# 事务

## 1.1事务概述

事务：指的是逻辑上的一组操作(sql语句)，组成这组操作的各个逻辑单元(sql)，**要么全都成功，要么全都失败**。

### 1.1.1事务管理方式一

**开启事务**  start transaction;
update account set money = money -100 where name='a';   
update account set money = money +100 where name='b'; 

**提交事务** **commit;**（sql语句对数据库产生的操作才会被永久的保存）

**a=1000 b=1000** 

**开启事务** start transaction;
update account set money = money -100 where name='a'; 

**出现异常**
update account set money = money +100 where name='b';

**a=1000 b=1000;**

**事务的回滚** **rollback****;**（只要没有commit 撤销已经成功执行的sql语句）

| **sql语句**          | **描述** |
| ------------------ | ------ |
| start transaction; | 开启事务   |
| commit;            | 提交事务   |
| rollback;          | 回滚事务   |

注意 : 不管是使用了 rollback还是 commit,都会结束事务!!!!!!!!!**

**只要不是通过commit提交的事务,其他任何情况下异常发生都会rollback.**

### 1.1.2事务管理方式二

使用命令

show variables like '%commit%'   查看当前自动提交状态,开启状态!!

使用命令开启或关闭自动提交状态

 set autocommit = 1; 开启 关闭了事务

 set autocommit = 0; 关闭 相当于开启了事务

## 1.2事务特征

### 1.2.1 事务的特性

* A 原子性  -- 事务不可拆分 一组sql不可以拆分  要么全部成功  要么全部失败!!!
* C 一致性 -- 事务前后操作  数据要保持一致  转账  准过去500  你就收到了500 转账失败  你就收不到钱!!!
* I  隔离性 -- (isolation 记住) 事务与事务之间不产生影响!!!
* D 持久性 -- 事务一旦结束 commit  rollback -- 执行的sql语句就是真的操作了数据库 数据库中的数据 就永久的发生了变化!!!   

### 1.2.2 事务的安全性问题

**脏读：**一个事务读到了另一个事务未提交的数据，导致查询结果不一致 (不允许出现的)

**不可重复读：**一个事务读到了另一个事务已经提交的update的数据，导致多次查询结果不一致。

**虚读/幻读：**一个事务读到了另一个事务已经提交的insert delete的数据，导致多次查询结果不一致。

### 1.2.3如何解决事务的安全性问题

**语法**

```sql
set session transaction isolation level 级别字符串
```

**read uncommitted:**脏读，不可重复读，虚读都有可能发生

**read committed:**避免脏读。但是不可重复读和虚读是有可能发生 oracle数据库  默认的隔离级别

**repeatable read:**避免脏读和不可重复读，但是虚读有可能发生。mysql的默认隔离级别

**serializable:**避免脏读，不可重复读，虚读。相当于单线程!! -- 相率那是相当的低!!!

效率问题

隔离级别越高  效率越低  安全性越高

**查看隔离级别**

```sql
select @@tx_isolation;
```

 ![1534481539633](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day06_%E4%BA%8B%E5%8A%A1%E4%B8%8EJDBC/%E7%AC%94%E8%AE%B0/img/1534481539633.png)

## 1.3jdbc概述

### 1.3.1 什么是jabc

JDBC其实就是SUN公司提供的一个**接口规范**，可以让我们java程序员使用java语言连接到数据库。

JDBC是Java访问数据库的标准规范，真正怎么操作数据库还需要具体的实现类，也就是**数据库驱动**。每个数据库厂商根据自家数据库的通信格式编写好自己**数据库的驱动**。所以我们只需要会调用JDBC接口中的方法即可，**数据库驱动由数据库厂商提供**。

数据库厂商 只要实现这套规范就可以了!!!

### 1.3.2jdbc开发步骤

```java
public class Test {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //注册驱动
        Class.forName("com.mysql.jdbc.Driver");
        //获得链接
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/jdbctest", "root", "1234");
        //获得执行SQL语句的对象
        Statement stat = conn.createStatement();
        //编写sql语句
        String sql="select * from lover";
        //执行sql语句
        ResultSet res = stat.executeQuery(sql);
        //遍历set集合
        while(res.next()){
        //getXxx()   Xxx代表获取的数据类型   （）里可以是表中列名或者索引值（从1开始）
            System.out.println(res.getString(3)+"----"+res.getString(2));
        }
        //释放资源
        res.close();
        stat.close();
        conn.close();

    }
}
```

| 接口/类                    | 作用                                       |
| ----------------------- | ---------------------------------------- |
| **DriverManager类**      | 1.管理和注册数据库驱动 <br />2.得到数据库连接对象           |
| **Connection接口**        | 一个连接对象，可用于创建Statement和PreparedStatement对象 |
| **Statement接口**         | 一个SQL语句对象，用于将SQL语句发送给数据库服务器。             |
| **PreparedStatement接口** | 一个SQL语句对象，是Statement的子接口                 |
| **Resultset接口**         | 用于封装数据库查询的结果集，返回给客户端Java程序               |

# 连接池

## 1常用连接池介绍

**DataSource**本身只是Oracle公司提供的一个接口规范，没有具体的实现，它的实现由连接池的数据库厂商去实现。我们只需要学习这个工具如何使用即可。常用的连接池实现组件有这些：

1. 阿里巴巴-德鲁伊**druid**连接池：Druid是阿里巴巴开源平台上的一个项目，整个项目由数据库连接池、插件框架和SQL解析器组成。该项目主要是为了扩展JDBC的一些限制，可以让程序员实现一些特殊的需求。

2. DBCP(DataBase Connection Pool)数据库连接池，是Apache上的一个Java连接池项目，也是Tomcat使用的连接池组件。dbcp没有自动回收空闲连接的功能。

3. **C3P0**是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。C3P0是异步操作的，所以一些操作时间过长的JDBC通过其它的辅助线程完成。目前使用它的开源项目有Hibernate，Spring等。C3P0有自动回收空闲连接功能。

4. Proxool数据库连接池技术，它是sourceforge下的一个开源项目，这个项目提供一个健壮、易用的连接池，最为关键的是这个连接池提供监控的功能，方便易用，便于发现连接泄漏的情况。


   **数据源接口中的方法**

| DataSource接口中的方法               | 作用            |
| ------------------------------ | ------------- |
| **Connection getConnection()** | 从连接池中得到一个连接对象 |

## 2.C3P0连接池的使用

| 构造方法                            | 描述                                  |
| ------------------------------- | ----------------------------------- |
| **ComboPooledDataSource()**     | 创建一个连接池对象，使用默认的配置参数(后面使用到配置文件再详细解释) |
| **ComboPooledDataSource(命名配置)** | 创建一个连接池对象，使用命名的配置参数(后面使用到配置文件再详细解释) |

| **方法**                 | **作用**           |
| ---------------------- | ---------------- |
| **getConnection**      | 从连接池中获得连接对象      |
| **setInitialPoolSize** | 设置初始化连接池数量       |
| **setMaxPoolSize**     | 设置最大连接池数量        |
| **setCheckoutTimeout** | 设置连接超时,超出时长抛出异常. |

#### 2.1配置文件c3p0-config.xml

只能写在src文件夹下

```xml
<c3p0-config>
    <!-- 使用默认的配置读取连接池对象 -->
    <default-config>
        <!--  1. 数据库的连接参数 -->
        <property name="driverClass">com.mysql.jdbc.Driver</property>
        <property name="jdbcUrl">jdbc:mysql:///jdbctest</property>
        <property name="user">root</property>
        <property name="password">root</property>

        <!-- 2. 连接池参数 -->
        <!--初始连接数-->
        <property name="initialPoolSize">5</property>
        <!--最大连接数-->
        <property name="maxPoolSize">10</property>
        <!--等待多久以后抛出异常-->
        <property name="checkoutTimeout">2000</property>
    </default-config>

    <!-- 命名配置 -->
    <named-config name="otherc3p0">
        <!--  连接参数 -->
        <property name="driverClass">com.mysql.jdbc.Driver</property>
        <property name="jdbcUrl">jdbc:mysql:///c3p0test</property>
        <property name="user">root</property>
        <property name="password">root</property>

        <!-- 连接池参数 -->
        <property name="initialPoolSize">5</property>
        <property name="maxPoolSize">8</property>
        <property name="checkoutTimeout">1000</property>
    </named-config>
</c3p0-config>
```
# JdbcTemplate

## 1.JdbcTemplate概述

JDBC已经能够满足大部分用户最基本的需求，但是在使用JDBC时，必须自己来管理数据库资源。

如：获取PreparedStatement，设置SQL语句参数，关闭连接等步骤。

JdbcTemplate就是Spring对JDBC的封装，目的是使JDBC更加易于使用。JdbcTemplate是Spring的一部分。JdbcTemplate处理了资源的建立和释放。他帮助我们避免一些常见的错误，比如忘了总要关闭连接。他运行核心的JDBC工作流，如PreparedStatement的建立和执行，而我们只需要提供SQL语句和提取结果。 

## 2.开发步骤

1. 环境准备
2. 创建JdbcTemplate对象，传入C3P0连接池
3. 调用execute()、update()、queryXxx()等方法

**API介绍**

| JdbcTemplate构造方法                         | 说明             |
| ---------------------------------------- | -------------- |
| **public JdbcTemplate(DataSource dataSource)** | 构造方法，传递数据源做为参数 |

#### 2.1创建jdbcTemplate工具类

~~~java
class JdbcUtils{
    //创建私有静态数据源成员变量ComboPooledDataSource
    public static final ComboPooledDataSource cpds = new ComboPooledDataSource();
    //创建公有的得到数据源(ComboPooledDataSource)的方法getDataSource()
    public static DataSource getDataSource() {
        return cpds;
    }
    //获取jdbctemplate对象
    public static JdbcTemplate getJdbcTemplate() {
        return new JdbcTemplate(cpds);
    }
    
}
~~~

**常用方法**

| 方法名            | 作用                  |
| -------------- | ------------------- |
| **execute()**  | 用于执行DDL语句，如：建表      |
| **update()**   | 用于执行DML语句，实现增删改操作   |
| **queryXxx()** | 用于执行DQL语句，实现各种查询的操作 |

**代码实现**

```java
import com.itheima.utils.JdbcUtils;
import org.springframework.jdbc.core.JdbcTemplate;
public class JdbcTemplateDemo {
    public static void main(String[] args) {
        //1. 创建JdbcTemplate对象
        JdbcTemplate jdbcTemplate =JdbcUtils.getJdbcTemplate();
        //2. 编写建表的SQL语句
        //准备sql语句
        String sql = "create table employee(" +
                "id int primary key auto_increment," +
                "name varchar(20)," +
                "gender varchar(2)," +
                "birthday date)";
        //3. 使用JdbcTemplate对象的execute()方法执行DDL语句
        jdbcTemplate.execute(sql);
    }
}

```

## 3.DQL查询语句

### 3.1API介绍

| 方法                   | 作用                                       |
| -------------------- | ---------------------------------------- |
| **query()**          | 通用的查询方法，有多个同名方法的重载，可以自定义查询结果集封装成什么样的对象。  |
| **queryForMap()**    | ![1531044735204](/1531044735204.png) 返回Map<String,Object>的查询结果，其中键是列名，值是表中对应的记录。用于查询结果只有1条记录的情况。如果结果集返回多条记录会出现异常. |
| **queryForObject()** | 返回查询只有单一对象的结果，这个单一结果应该是简单的数据类型，如：Integer.class, Long.class,String.class,不能直接封装成JavaBean对象。 用于聚合函数的查询结果。 |
| **queryForList()**   | ![1531044760518](/1531044760518.png)返回多条记录的查询结果，封装成一个List集合 默认List集合中的每个元素是Map对象，即List<Map<String,Object>>  如果要封装成List<JavaBean>对象，使用query()方法。 |

### 3.2一.查询一条数据存放至map

**查询一条记录封装成Map**

**需求:**

返回的结果集中如果只有一条记录，可以使用queryForMap()方法，将这条记录被封装成了Map对象

![1529072709929](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529072709929.png)

| 作用                       | 参数   |
| ------------------------ | ---- |
| sql语句                    | sql  |
| 可变参数,用来接收sql语句中 **?** 的值 | args |

**开发步骤**

1. 创建JdbcTemplate对象，传入数据源 
2. 编写SQL语句 
3. 使用JdbcTemplate对象的queryForMap()方法查询结果
4. 返回是一个Map对象

**代码实现**

```java
package com.itheima.temolate;

import com.itheima.utils.JDBCUtils;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.Map;

public class JdbcTemplateDemo {
    public static void main(String[] args) {
        //1. 创建JdbcTemplate对象，传入数据源
        JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource());
        //2. 编写SQL语句
        String sql = "select * from employee where id = ?";
        //3. 使用JdbcTemplate对象的queryForMap()方法查询结果
        Map<String, Object> map = jdbcTemplate.queryForMap(sql, 2);
        // 4. 返回是一个Map对象
        System.out.println(map);
    }

}

```

**查询结果**

 ![1529073052547](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529073052547.png)

### 3.3二.查询一条记录封装成bean(对象)

**需求**

查询id为1的一条记录封装成自定义的类

**分析**

使用queryForObject()查询1个学生，但queryForObject()必须要指定查询的结果集与JavaBean属性之间的对应关系，所以这个方法需要传递一个接口做为参数：RowMapper<T>。

![1529074297681](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529074297681.png)

**RowMapper**

 ![1529074400939](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529074400939.png)

通过泛型传入要封装的Bean类 例如Student.

![1529074465170](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529074465170.png)

将结果集映射成一个实体JavaBean对象

**参数：**

​	**rs**:表示结果集

​	**rowNum**:表示结果集有多少条记录

我们需要重写这个方法，指定属性与列之间的映射关系，代码中可以使用匿名内部类。

**准备实体类**

代码

```java
package com.itheima.beans;

import java.util.Date;

public class Employee {
    private int id;
    private String name;
    private String gender;
    private Date birthday;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }
    @Override
    public String toString() {
        return "Employee{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", gender='" + gender + '\'' +
                ", birthday=" + birthday +
                '}';
    }

}

```

**开发步骤**

1. 创建JdbcTemplate对象，传入数据源对象 
2. 编写SQL语句 
3. 使用JdbcTemplate对象的queryForObject ()方法查询结果，方法中传入一个接口的匿名内部类

**代码实现**

```java
package com.itheima.temolate;

import com.itheima.beans.Employee;
import com.itheima.utils.JDBCUtils;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;

public class JdbcTemplateDemo {
    public static void main(String[] args) {
        //1. 创建JdbcTemplate对象，传入数据源
        JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource());
        //2. 编写SQL语句
        String sql = "select * from employee where id = ?";
        //3. 使用JdbcTemplate对象的queryForObject ()方法查询结果，方法中传入一个接口的匿名内部类
        Employee employee = jdbcTemplate.queryForObject(sql, new RowMapper<Employee>() {

            @Override
            public Employee mapRow(ResultSet resultSet, int i) throws SQLException {
                    Employee empl = new Employee();
                    empl.setId(resultSet.getInt("id"));
                    empl.setName(resultSet.getString("name"));
                    empl.setGender(resultSet.getString("gender"));
                    empl.setBirthday(resultSet.getDate("birthday"));
                    return empl;
            }
        }, 1);
        // 4. 返回是一个Employee对象
        System.out.println(employee);
    }

}

```

### 3.4三.查询一条记录封装成bean类(星星)

**需求**

**查询id为1的一条记录封装成自定义的类**

如果每个JavaBean都需要自己封装每个属性，那开发效率将大打折扣，所以Spring JDBC提供了这个接口的实现类BeanPropertyRowMapper，使用起来更加方便。只需要在构造方法中传入Employee.class类对象即可，它会自动封装所有同名的属性。请看另一种写法：

**使用BeanPropertyRowMapper实现类**

 ![1529076375342](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529076375342.png)

**构造方法**

![1529076532993](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529076532993.png)

| 参数          | 作用                                  |
| ----------- | ----------------------------------- |
| mappedClass | 传入bean类的字节码对象,底层运用反射将数据封装到当前bean类中. |

**开发步骤**

1. 创建JdbcTemplate对象，传入数据源对象 
2. 编写SQL语句 
3. 使用JdbcTemplate对象的queryForObject ()方法查询结果，方法中传入BeanPropertyRowMapper的实现类

**代码实现**

```java
package com.itheima.temolate;

import com.itheima.beans.Employee;
import com.itheima.utils.JDBCUtils;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

public class JdbcTemplateDemo {
    public static void main(String[] args) {
        //1. 创建JdbcTemplate对象，传入数据源
        JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource());
        //2. 编写SQL语句
        String sql = "select * from employee where id = ?";
        //3. 使用JdbcTemplate对象的queryForObject ()方法查询结果，方法中传入BeanPropertyRowMapper的实现类
        Employee employee = jdbcTemplate.queryForObject(sql,new BeanPropertyRowMapper<>(Employee.class),1);
        // 4. 返回是一个Employee对象
        System.out.println(employee);
    }

}

```

**查询结果**

 ![1529076636288](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529076636288.png)

### 3.5四.查询多条记录封装Bean（星星星）

**需求**

查询多条记录封装成List<JavaBean>

这里需要使用**query**方法来实现

**BeanPropertyRowmapper实现了 RowMapper接口**

![1529076375342](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529076375342.png) 

**方法**

![1529077109056](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529077109056.png)

**可以将BeanPropertyRowmapper的对象作为参数传递给RowMapper -- 多态**

**代码**

```java
package com.itheima.temolate;

import com.itheima.beans.Employee;
import com.itheima.utils.JDBCUtils;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;

public class JdbcTemplateDemo {
    public static void main(String[] args) {
        //1. 创建JdbcTemplate对象，传入数据源
        JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource());
        //2. 编写SQL语句
        String sql = "select * from employee";
        //3. 使用JdbcTemplate对象的query()方法查询结果，方法中传入BeanPropertyRowMapper实现类对象
        List<Employee> emplList = jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(Employee.class));
        // 4. 返回是一个List<Employee>对象
        for (Employee employee : emplList) {
            System.out.println(employee);
        }
    }

}

```

**查询结果**

 ![1529077305857](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529077305857.png)

### 3.6五.查询一列数据

**需求:查询一列**

可以使用queryForList()方法，并且直接指定List<String>中的每个元素的类型为String.class

![1529077457846](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529077457846.png)

| 参数          | 作用                |
| ----------- | ----------------- |
| sql         | sql语句             |
| elementType | 要查询的数据的数据类型的字节码对象 |

**代码**

```java
package com.itheima.temolate;

import com.itheima.beans.Employee;
import com.itheima.utils.JDBCUtils;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;

public class JdbcTemplateDemo {
    public static void main(String[] args) {
        //1. 创建JdbcTemplate对象，传入数据源
        JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource());
        //2. 编写SQL语句
        String sql = "select name from employee";
        //3. 使用JdbcTemplate对象的queryForList()方法查询结果，方法中传入要查询的数据的数据类型
        List<String> list = jdbcTemplate.queryForList(sql, String.class);
        // 4. 返回是一个List<String>对象
        for (String s : list) {
            System.out.println(s);
        }
    }

}

```

**打印结果**

 ![1529077681248](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529077681248.png)

### 3.7查询多列数据封装成List

**需求:查询学生的编号和姓名这两列，使用queryForList()方法，默认封装成List<Map<String,Object>>对象**

 ![1529078506412](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529078506412.png)

![1529078566475](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529078566475.png)

**代码实现**

```java
package com.itheima.temolate;

import com.itheima.beans.Employee;
import com.itheima.utils.JDBCUtils;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;
import java.util.Map;

public class JdbcTemplateDemo {
    public static void main(String[] args) {
        //1. 创建JdbcTemplate对象，传入数据源
        JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource());
        //2. 编写SQL语句
        String sql = "select id,name from employee";
        //3. 使用JdbcTemplate对象的queryForList()方法查询结果
        List<Map<String, Object>> maps = jdbcTemplate.queryForList(sql);
        // 4. 返回是一个List<Map<String, Object>> 对象
        for (Map<String, Object> map : maps) {
            System.out.println(map);
        }
    }

}

```

**打印结果**

 ![1529078746239](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529078746239.png)

### 3.8七.查询所有数据封装成 List<Map<String,Object>>

**需求**

查询所有的员工，封装成List<Map<String,Object>>,使用queryForList()方法查询

![1529073374253](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529073374253.png)

![1529073387462](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529073387462.png)

**代码**

```java
package com.itheima.temolate;

import com.itheima.utils.JDBCUtils;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;
import java.util.Map;

public class JdbcTemplateDemo {
    public static void main(String[] args) {
        //1. 创建JdbcTemplate对象，传入数据源
        JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource());
        //2. 编写SQL语句
        String sql = "select * from employee";
        //3. 使用JdbcTemplate对象的queryForList()方法查询结果
        List<Map<String, Object>> maps = jdbcTemplate.queryForList(sql);
        // 4. 返回是一个List<Map<String, Object>>对象
        for (Map<String, Object> map : maps) {
            System.out.println(map);
        }
    }

}

```

**效果**

 ![1529073522033](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529073522033.png)

### 3.9案例八-聚合函数

**需求：**

查询一共有多少个员工，使用queryForObject()方法，指定参数为Integer.class类型

 ![1529078879466](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/Day07_JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E7%AC%94%E8%AE%B0/img/1529078879466.png)

| 参数           | 作用            |
| ------------ | ------------- |
| sql          | sql语句         |
| requiredType | 返回的数据类型的字节码对象 |

**代码**

```java
package com.itheima.temolate;

import com.itheima.utils.JDBCUtils;
import org.springframework.jdbc.core.JdbcTemplate;

public class JdbcTemplateDemo {
    public static void main(String[] args) {
        //1. 创建JdbcTemplate对象，传入数据源
        JdbcTemplate jdbcTemplate = new JdbcTemplate(JDBCUtils.getDataSource());
        //2. 编写SQL语句
        String sql = "select count(*) from employee";
        //3. 使用JdbcTemplate对象的queryForObject方法查询结果
        Integer num = jdbcTemplate.queryForObject(sql, Integer.class);
        // 4. 返回是一个Integer对象
        System.out.println("总共有" + num + "名员工");
    }

}

```

**查询结果**

共有五名员工









# servlet

## 1.servlet概述

servlet是运行在服务器上的程序，必须实现Servlet接口，重新service方法。

作用是：1，接受数据  2，处理数据  3，相应数据

## 2.servlet生命周期

* 何时创建

  ```tex
  第一次被访问的时候被创建
  ```

* 被谁创建

  ~~~tex
  Tomcat
  ~~~

* 如何感知自己被创建

  ```tex
  init方法
  ```

* 何时销毁

  ```tex
  项目卸载或关闭
  ```

* 被谁销毁

  ```tex
  Tomcat
  ```

* 如何感知自己被销毁

  ```tex
  destroy方法
  ```

* 被创建了几次

  ```tex
  创建一次
  ```

* 线程是否安全

  ```tex
  不安全
  ```



## 3.servlet立即加载

```tex
1. 在web.xml中给LifeCycleServlet的类路径添加以下配置
<load-on-startup>2</load-on-startup>

2. 在LifeCycleServlet的WebServler注解中配置loadOnStartup参数。
@WebServlet(value = "/lifecycle", loadOnStartup = 2)
```

- number取值小于0或不配置，被访问时才去加载
- number取值为0时，最先被加载
- number取值大于0时，数值越小Servlet越优先加载



# request

## 1.获取请求行信息

#### 相关API

- String getMethod()

  ```tex
  得到请求的方式：GET或POST
  ```

- String getRequestURI()

  ```tex
  Uniform Resource Identifier 统一资源标识符，代表一个资源的名字
  URI = ContextPath + ServletPath
  ```

- StringBuffer getRequestURL()

  ```tex
  Uniform Resource Locator 统一资源定位符，代表一个可以访问地址
  ```

- String getProtocol()

  ```tex
  得到协议和版本
  ```

- 【重点】String getContextPath()

  ```tex
  得到当前项目的访问地址
  ```

- 【重点】String getServletPath()

  ```tex
  得到当前Servlet的访问地址
  ```

## 2.获取请求头信息

#### 相关API

- 【重点】String getHeader(String headName)

  ```tex
  指定请求头中键，得到相应的值
  ```

- Enumeration<String> getHeaderNames()

  ```tex
  得到请求头中所有的键
  ```

##### Enumeration接口

```tex
Enumeration是枚举类型的集合，类似于迭代器
```

| Iterator  | Enumeration       |
| --------- | ----------------- |
| hasNext() | hasMoreElements() |
| next()    | nextElement()     |

- boolean hasMoreElements()

  ```tex
  判断是否还有下一个元素，如果有返回true
  ```

- E nextElement()

  ```tex
  得到当前元素，并且向下移动一个元素
  ```

## 3.获取请求参数

- POST

  ```tex
  username=user&password=pass
  ```

- GET

  ```tex
  GET /http_request/login?username=user&password=pass HTTP/1.1
  ```

#### 相关API

- String getParameter(String name)

  ```tex
  通过参数名得到参数的值
  ```

- String[] getParameterValues(String name)

  ```tex
  通过参数名得到一组参数值，返回是字符串的数组
  ```

- 【非重点】Enumeration<String> getParameterNames()

  ```tex
  得到所有参数的名字，返回是枚举的类型
  ```

- Map<String, String[]> getParameterMap()

  ```tex
  得到表单提交的所有参数名和参数值，封装成一个Map集合
  ```

## 4.转发

```java
request.getRequestDispatcher("/resourceB").forward(request,response);
```



# response

## 1.响应行相关API

- void setStatus(int statusCode)

  ```tex
  设置响应行-状态码，Tomcat不会协助添加错误信息
  ```

- void sendError(int errorCode, String msg)

  ```tex
  设置状态码(errorCode)，并且Tomcat会协助添加错误信息(msg)
  ```

## 2 响应头相关API

| 状态头                 | 说明                                       |
| ------------------- | ---------------------------------------- |
| Server              | 描述服务器信息，包含Web容器信息、服务器系统信息                |
| Content-Length      | 描述响应体的长度(字符数)                            |
| Content-Type        | 请求体的编码格式，以及超文本类型。常见的有text/html， application/xml，application/json |
| Location            | 指定响应的路径，需要与状态码302配合使用，完成跳转               |
| Refresh             | 3;url=www.itcast.cn 。                    |
| Content-Disposition | attachment; filename=1.gif 常用于文件下载，attachment指定，被访问的资源是一个下载(attachment)的资源，下载所使用的文件名为(1.gif) |

- void setHeader(String name, String value)

  ```java
  在响应头中，设置一个Header。Header所对应的名字(name)，以及Header所对应的值(value)  
      需求：三秒后跳转到指定网站
      response.setHeader("Refresh","3;url=http://www.baidu.com")
  ```

- void setContentType(String type)[重点]

  ```tex
  在响应头中，设置一个Header。Header所对应的名字为Content-Type，Header所对应的值为(value)  
  response.setContentType("text/html;charset=utf-8")
  ```

## 3.响应体相关API

- PrintWriter getWriter()      **字符流**
- OutputStream getOutputStream()         **字节流**

#### 响应体乱码解决

response.setContentType("text/html;charset=utf-8")



## 4.浏览器跳转技术-重定向

response.sendRediret(String location)

#### 重定向与转发的区别

**转发**

request.getRequestDispatcher("/资源路径").forward(request, response)

**重定向**

response.sendRedirect("/资源路径/地址")

- 请求次数
  - 转发：请求了一次
  - 重定向: 请求了两次
- 浏览器地址
  - 转发: 浏览器地址不变
  - 重定向: 浏览器地址会变
- 跳转的位置 
  - 转发：在服务器内部完成的跳转
  - 重定向：在浏览器 完成的跳转



# ServletContext

## 1 ServletContext是什么

```java
Servlet用于与Web容器(Tomcat)通信的一组方法，对于每个Java虚拟机、每个Web应用都有一个上下文

Web应用的上下文，封装的是当前Web应用的上下文信息
```

## 2 ServletContext的获取方式

- this.getServletContext()

  ```tex
  this为GenericServlet的派生类
  ```

- request.getServletContext()

## 3 ServletContext的作用

### 相关API

- String getRealPath(String path)

  获取真实路径

  如果path当中的文件，不存在的话，还是会返回

- InputStream getResourceAsStream(String path)

  从资源当中获取一个输入流

  如果path当中的文件，不存在的话，返回值是null

### 获得Web应用的全局初始化参数

web.xml配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <context-param>
        <param-name>username</param-name>
        <param-value>root</param-value>
    </context-param>

    <context-param>
        <param-name>password</param-name>
        <param-value>pwd</param-value>
    </context-param>
</web-app>
```

- String getInitParameter(String name)
- Enumeration<String> getInitParameterNames()

```java
package com.itheima.day09;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = "InitParamServlet")
public class InitParamServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        ServletContext servletContext = this.getServletContext();
        System.out.println("username: " + servletContext.getInitParameter("username"));
        System.out.println("password: " + servletContext.getInitParameter("password"));
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}
```

## 4 ServletContext与Request域的对比

上下文域，在Web应用被Web容器加载的时候被创建，在Web程序被卸载的时候被销毁。在Web应用程序内部有效

|      | 请求域                      | 上下文域              |
| ---- | ------------------------ | ----------------- |
| 创建   | 当服务器接收了浏览器的请求时，被Tomcat创建 | Web应用加载时被Tomcat创建 |
| 销毁   | 当服务器所有的业务处理完成时，被Tomcat销毁 | Web应用卸载时被Tomcat销毁 |
| 作用范围 | 一个用户的一次请求                | 所有用户的所有请求         |

# Cookie&Httpsession

## 1.会话概述

### 会话技术

- Cookie

  ```tex
  在客户端保存用户数据的一种技术

  数据存储在客户端本地，减少服务器端的存储的压力，安全性不好，客户端可以清除cookie
  ```

- Session

  ```tex
  在服务端保存用户数据的一种技术

  将数据存储到服务器端，安全性相对好，增加服务器的压力
  ```

### 会话的作用

HTTP协议是无状态的网络传输协议。会话技术就是为了解决多次请求和响应时，服务器识别或区分客户端状态的技术。

## 2.Cookie

### 2.1Cookie相关API

- Cookie(String name, String value)
- String Cookie.getName()
- String Cookie.getValue()
- Cookie[] HttpServletRequest.getCookies()
- void HttpServletResponse.addCookie(Cookie cookie)

### 2.2设置Cookie为中文乱码解决方法

**编码**

* URlUncoder.encode(String s,String enc)

**解码**

* URLDecoder.decode(String s,String enc)

**<u>注意：编码和解码的编码集要一致！！！！**</u>

### 2.3cookie设置过期时间

- Cookie.setMaxAge(int expiry)

  ```tex
  设置Cookie过期的时间，单位是秒。
  如果值为正数，则表示cookie将在数秒之后过期。
  负值意味着cookie不是持久存储的，将在Web浏览器退出时删除。
  零值会导致cookie被删除。
  ```

## 3.Session

### 3.1session相关API

- HttpSession Request.getSession()
- String HttpSession.getId()
  - 获取Session的ID(唯一标识)(箱子的票号)
- long HttpSession.getCreationTime()
  - 获取Session的创建时间
  - new SimpleDateFormate("yyyy-MM-dd HH:mm:ss").format(getCreationTime())
- long HttpSession.getLastAccessedTime()
  - 获取Session的上次访问时间
- boolean HttpSession.isNew()
  - 判断Session是否是新创建
- ServletContext HttpSession.getServletContext()

### 3.2Session设置过期时间

- HttpSession.setMaxInactiveInterval()

  ```tex
  单独设置Session的非活动(过期)时间(秒)
  如设置时间30s，在20s时再次访问，还需再等待30s才销毁
  ```

- HttpSession.invalidate()

  ```tex
  立即销毁Session
  ```

- web.xml

  ```xml
  <session-config>
      <!-- 分钟 -->
      <session-timeout>5</session-timeout>
  </session-config>
  ```

### 3.3 getSession的内部活动

![HttpSession_Creative_Activity](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/javaweb%E9%A2%84%E4%B9%A0%E8%B5%84%E6%96%99/B-Web-Core/D-Cookie%20&%20Session/img/HttpSession_Creative_Activity.png)

1. 第1次用户访问没有会话，由服务器调用s()创建一个会话对象。分配了一个会话ID给当前的用户。
2. 创建一个Cookie，名字叫：JSESSIONID，把会话ID发送给浏览器。
3. 浏览器默认是浏览器关闭Cookie就过期，只要不关闭Cookie就会将会话ID发送给服务器
4. 服务器得到上次的会话ID，与内存中的会话比较，找到它的会话空间继续访问。
5. 不同的用户，会话ID是不同的。

### 3.4会话域【重点】

- void HttpSession.setAttribute(String name, Object value)
  - 往域当中设置一个属性
- Object HttpSession.getAttribute(String name)
  - 从域当中拿一个属性
- void HttpSession.removeAttribute(String name)
  - 从域当中删除一个属性

## Servlet三个作用于总结

- 作用域对象的获得方式

  | 作用域  | 获得方式                                     |
  | ---- | ---------------------------------------- |
  | 请求域  | 参数request                                |
  | 会话域  | request.getSession()                     |
  | 上下文域 | GenericServlet getServletContext()<br/>request.getServletContext()<br/>session.getServletContext() |

- 作用域的生命周期

  | 作用域  | 接口名                | 作用范围      | 生命周期                                     |
  | ---- | ------------------ | --------- | ---------------------------------------- |
  | 请求域  | HttpServletRequest | 一个用户的一次请求 | 在浏览器发送了请求时，由Tomcat创建<br/>在请求结束(服务器处理完了所有的业务 )时，由Tomcat销毁 |
  | 会话域  | HttpSession        | 一个用户的多次请求 | 用户第一次(浏览器的Cookie当中，没有JSESSIONID)请求时，由Tomcat创建<br/>在会话过期时，或者调用invalidate()销毁 |
  | 上下文域 | ServletContext     | 所有用户的所有请求 | 在服务器/Web应用加载时/启动时，由Tomcat创建<br/>在服务器/Web应用卸载时/关闭时，由Tomcat销毁 |

- 三个作用域共同的方法

  | 功能   | 方法                                    |
  | ---- | ------------------------------------- |
  | 存放数据 | setAttribute(String name, Object obj) |
  | 获取数据 | Object getAttribute(String name)      |
  | 删除数据 | removeAttribute(String name)          |


# Mybatis

## 1.mybatis介绍

![1563972590053](assets/1563972590053.png)

特点：1） 支持自定义SQL、存储过程、及高级映射

2） 实现自动对SQL的参数设置

3） 实现自动对结果集进行解析和封装

4） 通过XML或者注解进行配置和映射，大大减少代码量

5） 数据源的连接信息通过配置文件进行配置

**SSH  spring  struts2  Hibernate  （过时）**

**SSM  Spring  SpringMVC  Mybatis （主流）** 

## 2.mybatis框架结构

![563972785221](assets/1563972785221.png)

1、 配置文件

全局配置文件：mybatis-config.xml作用：配置数据源，引入映射文件

映射文件：XxMapper.xml 作用：配置sql语句、参数、结果集封装类型等

2、 SqlSessionFactory作用：获取SqlSession

通过new SqlSessionFactoryBuilder().build(inputStream)来构建，inputStream：读取配置文件的IO流

3、 SqlSession作用：执行CRUD操作

4、 Executor

执行器，SqlSession通过调用它来完成具体的CRUD

它是一个接口，提供了两种实现：缓存的实现、数据库的实现

5、 Mapped Statement

在映射文件里面配置，包含3部分内容：

具体的sql语句，sql执行所需的参数类型，sql执行结果的封装类型

参数类型和结果集封装类型包括3种：

HashMap，基本数据类型，pojo

### 2.1**log4j.properties(引入日志文件)**

```properties
log4j.rootLogger=DEBUG,A1
log4j.logger.org.apache=DEBUG
log4j.appender.A1=org.apache.log4j.ConsoleAppender
log4j.appender.A1.Target=System.err
log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%-d{yyyy-MM-dd HH:mm:ss,SSS} [%t] [%c]-[%p] %m%n
```



### 2.2**jdbc.properties**

```pro
jdbc.driverClass = com.mysql.jdbc.Driver
jdbc.url = jdbc:mysql:///mybatis
jdbc.username = root
jdbc.password = root
```



### 2.3**mybatis-config.xml**

```xml
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!--引入外部properties配置文件-->
    <properties resource="jdbc.properties"></properties>
    <!--开启驼峰匹配-->
    <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>
    <!--开启别名包扫描，name：包路径，扫描的别名就是类名，并且大小写不敏感-->
    <typeAliases>
        <package name="bean"/>
    </typeAliases>
    <!-- 环境：说明可以配置多个，default:指定生效的环境 -->
    <environments default="development">
        <!-- id:环境的唯一标识 -->
        <environment id="development">
            <!-- 事务管理器，type：类型 -->
            <transactionManager type="JDBC" />
            <!-- 数据源：type-池类型的数据源 -->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driverClass}" />
                <property name="url" value="${jdbc.url}" />
                <property name="username" value="${jdbc.username}" />
                <property name="password" value="${jdbc.password}" />
            </dataSource>
        </environment>
    </environments>
    <!-- 映射文件 -->
    <mappers>
        <mapper resource="UserMapper.xml"/>
    </mappers >
</configuration>
```

### 2.4**Mapper.xml**

```xml
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="mapper.UserMapper">

    <!--sql语句体-->

</mapper>
```

## 3.动态代理Mapper实现类步骤

1.有一个bean对象类

2.与bean对象对应的Mapper接口

3.Mapper.xml中namespace必须是Mapper接口的全路径名称。且标签id必须与方法名相同    resultType要与方法的返回值类型相同

4.MapperTest中在测试前做初始化动作

```java
public class UserMapperTest{
    private UserMapper usermappe
    @Before
    public void setUp() throws Exception {
     	// 读取mybatis的全局配置文件
		InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml");
		// 构建sqlSessionFactory
		SqlSessionFactory sqlSessionFactory =new SqlSessionFactoryBuilder().build(inputStream);
		// 获取sqlSession会话, true 表示自动提交事务
		SqlSession sqlSession = sqlSessionFactory.openSession(true);
		// 初始化useMapper
		this.userMapper = sqlSession.getMapper(Mapper.class);   
    }
    @Test
    //-------
        
}
```

### **${}和#{}的区别**

![1563974927506](assets/1563974927506.png)

### sql片段

sql语句中select * 运行效率低下。一般都会把*转换成所有列名。如何把列名封装供所有sql语句使用呢

![1563975402665](assets/1563975402665.png)

也可以封装在xml文件中。供所有的Mapper配置文件使用

![img](assets/wps1.jpg) 

内容如下：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!-- namespace(命名空间)：映射文件的唯一标识 -->
<mapper namespace="CommonSQL">

	<sql id="commonSql">
		id,user_name,
			password,
			name,
			age,
			sex,
			birthday,
			created,
			updated
	</sql>
</mapper>
```

定义好sql片段的映射文件之后，接下来就该使用它了，首先应该把该映射文件引入到mybatis的全局配置文件中（mybatis-config.xml）：

![img](assets/wps2.jpg) 

 

最后在需要使用该sql片段的地方通过include标签的refId属性引用该sql片段：

```xml
<include refId=”名称空间.sql片段的id” />
```

在UserMapper.xml的映射文件中，进一步改造根据用户名查询用户信息

![img](assets/wps3.jpg) 

 

## 4.动态sql

### 4.1 if

案例：查询男性用户，如果输入了用户名，按用户名模糊查询

在UserMapper接口中定义方法

```java
	/**
	 * 查询男性用户，如果输入了用户名，按用户名模糊查询
	 * @param userName
	 * @return
	 */
	public List<User> queryUserListLikeUserName(@Param("userName")String userName);
```

Mapper.xml

```xml
	<select id="queryUserListLikeUserName" resultType="User">
		select * from tb_user where sex=1
		<!-- if:判断
			test：OGNL表达式
		 -->
		<if test="userName!=null and userName.trim()!=''">
			 and user_name like '%' #{userName} '%'
		</if>
	</select>
```

MapperTest

```java
	@Test
	public void testQueryUserListLikeUserName(){
		List<User> users = this.userMapper.queryUserListLikeUserName("zhang");
		for (User user : users) {
			System.out.println(user);
		}
	}
```

### 4.2  choose when otherwise

查询男性用户，如果输入了用户名则按照用户名模糊查找，否则如果输入了年龄则按照年龄查找，否则查找用户名为“zhangsan”的用户。

模糊匹配时   '%#{param}%'   应该写成  '%'  #{param} '%'

在UserMapper接口中定义方法

```java
	/**
	 * 查询男性用户，如果输入了用户名则按照用户名模糊查找，否则如果输入了年龄则按照年龄查找，否则查找用户名为“zhangsan”的用户。
	 * @param userName
	 * @param age
	 * @return
	 */
	public List<User> queryUserListLikeUserNameOrAge(@Param("userName")String userName, @Param("age")Integer age);
```

Mapper.xml

```xml
	<select id="queryUserListLikeUserNameOrAge" resultType="User">
		select * from tb_user where sex=1 
		<!-- choose:条件选择
			when：test-判断条件，一旦有一个when成立，后续的when都不再执行
			otherwise：所有的when都不成立时，才会执行
		 -->
		<choose>
			<when test="userName!=null and userName.trim()!=''">and user_name like '%' #{userName} '%'</when>
			<when test="age != null">and age = #{age}</when>
			<otherwise>and user_name = 'zhangsan' </otherwise>
		</choose>
	</select>
```

MapperTest

```java
	@Test
	public void testQueryUserListLikeUserNameOrAge(){
		List<User> users = this.userMapper.queryUserListLikeUserNameOrAge(null, null);
		for (User user : users) {
			System.out.println(user);
		}
	}
```

### 4.3 **where**

案例：查询所有用户，如果输入了用户名按照用户名进行模糊查询，如果输入年龄，按照年龄进行查询，如果两者都输入，两个条件都要成立。

在UserMapper接口中定义方法

```java
	/**
	 			 * @param userName
	 * @param age
	 * @return
	 */
	public List<User> queryUserListLikeUserNameAndAge(@Param("userName")String userName, @Param("age")Integer age);
```

Mapper.xml

```xml
	<select id="queryUserListLikeUserNameAndAge" resultType="User">
		select * from tb_user
		<!-- 
			自动添加where关键字
			有一定的纠错功能：去掉sql语句块之前多余的一个and|or
			通常结合if或者choose使用
		 -->
		<where>
			<if test="userName!=null and userName.trim()!=''">user_name like '%' #{userName} '%'</if>
			<if test="age!=null">and age = #{age}</if>
		</where>
	</select>
```

MapperTest

```java
	@Test
	public void testQueryUserListLikeUserNameAndAge(){
		List<User> users = this.userMapper.queryUserListLikeUserNameAndAge(null, 30);
		for (User user : users) {
			System.out.println(user);
		}
	}
```

### 4.4 set

案例：修改用户信息，如果参数user中的某个属性为null，则不修改

在UserMapper接口中定义方法

```java
	/**
	 * 修改用户信息，如果参数user中的某个属性为null，则不修改。
	 * @param user
	 */
	public void updateUserSelective(User user);
```

Mapper.xml

```xml
	<update id="updateUserSelective" >
		UPDATE tb_user
		<!-- 
			set自动添加set关键字
			也有一定的纠错功能：自动去掉sql语句块之后多余的一个逗号
		 -->
		<set>
			<if test="userName!=null and userName.trim()!=''">user_name = #{userName},</if>
			<if test="password!=null and password.trim()!=''">password = #{password},</if>
			<if test="name!=null and name.trim()!=''">name = #{name},</if>
			<if test="age!=null">age = #{age},</if>
			<if test="sex!=null">sex = #{sex},</if>
			updated = now(),
		</set>
		WHERE
			(id = #{id});
	</update>
```

MapperTest

```java
	@Test
	public void testUpdateUserSelective(){
		User user = new User();
		user.setAge(18);
		user.setName("柳岩");
		user.setPassword("123456");
		user.setUserName("yanyan2");
//		user.setSex(3);
		user.setBirthday(new Date());
		user.setId(12l);
		this.userMapper.updateUserSelective(user);
	}
```

### 4.5 foreach

案例：按照多个id查询用户信息

在UserMapper接口中定义方法

```java
	/**
	 * 根据多个id查询用户信息
	 * @param ids
	 * @return
	 */
	public List<User> queryUserListByIds(@Param("ids")Long[] ids);
```

Mapper.xml

```xml
	<select id="queryUserListByIds" resultType="User">
		select * from tb_user where id in 
		<!-- 
			foreach:遍历集合
			collection：接收的集合参数
			item：遍历的集合中的一个元素
			separator:分隔符
			open:以什么开始
			close：以什么结束
		 -->
		<foreach collection="ids" item="id" separator="," open="(" close=")">
			#{id}
		</foreach>
	</select>
```

MapperTest

```java
	@Test
	public void testQueryUserListByIds(){
		List<User> users = this.userMapper.queryUserListByIds(new Long[]{1l,2l,3l,4l});
		for (User user : users) {
			System.out.println(user);
		}
	}
```



## 5.高级查询

表关系示意图

![1563976730434](assets/1563976730434.png)

### 5.1 一对一查询

需求：根据订单号查询出订单信息，并查询出该订单的下单人信息

分析：从订单的角度看用户与订单的关系是一对一。可以在Order类中添加User对象

![1563976953148](assets/1563976953148.png)

OrderMapper.xml

```xml
在OrderMapper.xml中配置，结果集的映射，这时必须使用resultMap：
	<resultMap type="Order" id="orderUserMap" autoMapping="true">
		<id column="id" property="id"/>
		<!-- 
			association:一对一的映射
			property：java的属性名
			javaType：属性名对应的java类型
			autoMapping:开启自动映射
			子标签：参照resultMap
		 -->
 		<association property="user" javaType="User" autoMapping="true">
			<id column="user_id" property="id"/>
		</association>
	</resultMap>
	
	<!-- resultType不能完成user信息的映射，必须使用resultMap，resultMap的值对应resultMap标签的id，resultMap和resultType必须二选一 -->
	<select id="queryOrderWithUser" resultMap="orderUserMap">
		select * from tb_order a 
			LEFT JOIN tb_user b on a.user_id=b.id
		where a.order_number = #{number}
	</select>
```

### 5.2 一对多查询

需求：查询订单，查询出下单人信息并且查询出订单详情。

分析：订单与订单详情是一对多关系，在订单类中添加详情集合对象

​           与用户是一对一关系

![1563977146415](assets/1563977146415.png)



```xml
	<resultMap type="Order" id="orderUserDetailMap" autoMapping="true">
		<id column="id" property="id"/>
		<association property="user" javaType="User" autoMapping="true">
			<id column="user_id" property="id"/>
		</association>
		<!-- 
			collection:一对多的查询
			property:属性名
			javaType：集合类型
			ofType：集合中的元素类型
			autoMapping：开启自动映射
			子标签：参照resultMap
		 -->
		<collection property="detailList" javaType="list" ofType="Orderdetail" autoMapping="true">
			<id column="detail_id" property="id"/>
		</collection>
	</resultMap>
	
	<select id="queryOrderWithUserDetail" resultMap="orderUserDetailMap">
		select *,c.id as detail_id from tb_order a
			LEFT JOIN tb_user b on a.user_id=b.id
			LEFT JOIN tb_orderdetail c on a.id=c.order_id
		where a.order_number=#{number}
	</select>
```

### 5.3 多对多查询

需求：查询订单，查询出下单人信息并且查询出订单详情中的商品数据。

分析：订单和订单详情是 1:n 关系 在订单类中添加详情集合对象

​	    订单详情和商品是 1:1 关系 在详情类中添加商品对象

![1563977573822](assets/1563977573822.png)

```xml
	<resultMap type="Order" id="orderUserDetailItemMap" autoMapping="true">
		<id column="id" property="id"/>
		<association property="user" javaType="User" autoMapping="true">
			<id column="user_id" property="id"/>
		</association>
		<collection property="detailList" javaType="list" ofType="Orderdetail" autoMapping="true">
			<id column="detail_id" property="id"></id>
			<association property="item" javaType="Item" autoMapping="true">
				<id column="item_id" property="id"/>
			</association>
		</collection>
	</resultMap>
	
	<select id="queryOrderWithUserDetailItem" resultMap="orderUserDetailItemMap">
		select *,c.id as detail_id from tb_order a
			LEFT JOIN tb_user b on a.user_id=b.id
			LEFT JOIN tb_orderdetail c on a.id=c.order_id
			LEFT JOIN tb_item d on c.item_id=d.id
		where a.order_number=#{number}
	</select>
```

### 5.4 高级查询总结

**resutlType无法帮助我们自动的去完成映射，所以只有使用resultMap手动的进行映射**

resultMap:

type 结果集对应的数据类型 

id 唯一标识，被引用的时候，进行指定

autoMapping 开启自动映射

extends 继承

子标签：

association：一对一的映射

​	property 定义对象的属性名

​	javaType 属性的类型

​	autoMapping 开启自动映射

collection：一对多的映射

​	property 定义对象的属性名

​	javaType 集合的类型

​	ofType 集合中的元素类型

​	autoMapping 开启自动映射







# Spring

## 1.Spring概述

### 1.1 什么是Spring

spring的出现是为了解决企业应用程序开发的复杂性 它是一个分层的，javase/ee 一站式，轻量级开源框架。

### 1.2 Spring的体系结构

![img](assets/wps1-1564363531854.jpg)

## 2.IOC控制反转

### 2.1配置applicationContext.xml 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd">

<!-- bean: spring工厂创建的一个对象(反射机制)
	id/name:对象的名字,可以用来引用或者获取对象, 一般为类名或接口名称的首字母小写
	class:要创建的对象类型的类字符串,类名全路径
 -->
<bean id="userDAO" class="cn.itcast.spring.a_quickstart.UserDAOImpl" />

</beans>
```

在程序中创建Sprin工厂对象，通过工厂对象加载Spring的xml配置文件中配置的bean对应的对象

UserServiceImpl.java:

```java
	 //spring配置方式,创建spring工厂,加载spring配置文件
	 ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
	 //从spring工厂中获取对象,通过bean的id/name
	 IUserDAO userDAO = (IUserDAO) ac.getBean("userDAO");
	 userDAO.findUserByUsernameAndPassword();
```

### 2.2DI依赖注入的实现

步骤一:将service对象也交给spring容器管理

applicationContext.xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd">

<!-- bean: spring工厂创建的一个对象(反射机制)
	id/name:对象的名字,可以用来引用或者获取对象, 一般为类名或接口名称的首字母小写
	class:要创建的对象类型的类字符串,类名全路径
 -->
<bean id="userDAO" class="cn.itcast.spring.a_quickstart.UserDAOImpl" />

<bean id ="userService" class="cn.itcast.spring.a_quickstart.UserServiceImpl">
	<!-- 注入对象 -->
	<!-- property 根据类中的setter方法进行属性注入 -->
	<!-- name:setter方法的后缀小写,比如setXxx 对应的name为xxx -->
	<!-- ref:引用哪一个bean(对象),值为bean的id/name -->
	<property name="userDAO" ref="userDAO" />
</bean>

</beans>
```

步骤二:在程序中定义属性提供setter方法：

UserServiceImpl.java

```java
public class UserServiceImpl implements IUserService{
	//定义属性
	private IUserDAO userDAO;
	public void setUserDAO(IUserDAO userDAO) {
		this.userDAO = userDAO;
	}
	public void login() {
		 System.out.println("UserServiceImpl-service层方法调用了");
		 //ioc:依赖注入
		 userDAO.findUserByUsernameAndPassword();	
	}
```

步骤三:测试运行,此时获取对象必须从spring工厂获取(在spring容器配置中才有依赖注入,自己创建的对象没有注入依赖关系)

```java
public class SpringTest {
	//测试
	@Test
	public void test(){
		//创建service的示例
		//IUserService userService = new UserServiceImpl();
		//userService.login();	
		//创建spring工厂,获取spring管理的对象
	ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
		IUserService userService = (IUserService) ac.getBean("userService");
		userService.login();		
	}	
}
```

## 3.实例化Bean的四种方式

### 3.1 方式一：无参构造器

一：创建Bean.java

二：在spring容器applicationcontext.xml中配置

```xml
<!-- 实例化 bean的四种方式 -->
	<!-- 1.默认构造器实例化对象 -->
	<bean id ="bean1" class="cn.itcast.spring.b_xmlnewbean.Bean1" />
```

三：创建测试类获取bean

```java
public class SpringTest {
	
	@Test
	public  void test(){
		//创建spring工厂
		ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
		//1.默认构造器获取bean对象
		Bean1 bean1 = (Bean1) ac.getBean("bean1");
		System.out.println(bean1);
	}

}
```

### 3.2 方式二：静态工厂方法

一：创建Bean.java

二：创建BeanFactory.java

```java
//静态工厂
public class Bean2Factory {
	
	//静态方法，用来返回对象的实例
	public static Bean2 getBean2(){
		//在做实例化的时候，可以做其他的事情，即可以在这里写初始化其他对象的代码
		//Connection conn....
		return new Bean2();
	}

}
```

三：Spring的容器applicationContext.xml

```xml
<!-- 2.静态工厂获取实例化对象 -->
	<!-- class:直接指定到静态工厂类, factory-method: 指定生产实例的方法, spring容器在实例化工厂类的时候会自动调用该方法并返回实例对象 -->
	<bean id = "bean2" class="cn.itcast.spring.b_xmlnewbean.Bean2Factory" factory-method="getBean2" />
```

四：测试类进行测试

```java
@Test
	public void test(){
		//先构建实例化获取spring的容器（工厂、上下文）
		ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
		//2.静态工厂
		Bean2 bean2=(Bean2) applicationContext.getBean("bean2");
		System.out.println(bean2);
	}
```

### 3.3 方式三：实例化工厂方法

一：创建Bean.java

二：创建实力工厂BeanFactory类

```java
//实例工厂:必须new工厂--》bean
public class Bean3Factory {
	//普通的方法，非静态方法
	public Bean3 getBean3(){
		//初始化实例对象返回
		return new Bean3();
	}
}
```

三：配置applicationcontext.xml

```xml
    <!-- 3：实例工厂的方式实例化bean -->
	<bean id="bean3Factory" class="cn.itcast.spring.b_xmlnewbean.Bean3Factory"/>
	<!-- factory-bean相当于ref：引用一个bean对象 -->
	<bean id="bean3" factory-bean="bean3Factory" factory-method="getBean3"/>
```

四：使用测试代码测试

```java
@Test
	public void test(){
		//先构建实例化获取spring的容器（工厂、上下文）
		ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
		//3.实例工厂
		Bean3 bean3=(Bean3) applicationContext.getBean("bean3");
		System.out.println(bean3);
	}
```

### 3.4 方式四：FactoryBean方式

一：创建Bean：

二：创建BeanFactory：

```java
import org.springframework.beans.factory.FactoryBean;

public class Bean4Factory implements FactoryBean<Bean4> {
   
   
   //产生对象
   public Bean4 getObject() throws Exception {
      return new Bean4();
   }

   public Class<?> getObjectType() {
      return null;
   }

   public boolean isSingleton() {
      return false;
   }
}

```

三：配置applicationcontext.xml:

```xml

<!--方式四:FactoryBean-->
<!--spring在实例化对象的时候回判断是否该对象实现了FactoryBean接口,如果实现了就直接调用getObject()方法,并返回执行结果-->
<bean id="bean4" class="cn.itcast.spring.b_xmlnewbean.Bean4Factory"/>
```

## 4.Bean的作用域

![img](assets/wps2-1564367058043.jpg)

singleton:在一个spring容器中，对象只有一个实例。

prototype：在一个spring容器中，存在多少个实例，每次getBean都返回一个新的实例。

```xml
    <!-- 
		bean的作用范围
		scope:配置作用范围的，默认值就是singleton单例
	 -->
	<!-- 单例 -->
	<!-- <bean id="singletonBean" class="cn.itcast.spring.c_xmlscope.SingletonBean" scope="singleton"/> -->
	<bean id="singletonBean" class="cn.itcast.spring.c_xmlscope.SingletonBean"/>
	<!-- 多例 -->
	<bean id="prototypeBean" class="cn.itcast.spring.c_xmlscope.PrototypeBean" scope="prototype"/>
```

## 5.Bean属性的依赖注入

### 5.1构造器参数注入constructor-arg

一：构造器参数注入属性值

```java
//目标，构造器参数注入，new car直接将参数的值直接赋值
public class Car {
	private Integer id;
	private String name;
	private Double price;
	//有参构造
	public Car(Integer id, String name, Double price) {
		this.id = id;
		this.name = name;
		this.price = price;
	}
	@Override
	public String toString() {
		return "Car [id=" + id + ", name=" + name + ", price=" + price + "]";
	}
}
```

二：applicationcontext.xml

```xml
<!-- 构造器注入属性的值 -->
	<bean id="car" class="cn.itcast.spring.e_xmlpropertydi.Car">
		<!--constructor-arg：告诉spring容器，要调用有参构造方法了，不再调用默认的构造方法了  
		new Car(1,"宝马",99999d)
		参数第一组：定位属性
		    * index:根据索引定位属性，0表示第一个位置
			* name：根据属性参数名称定位属性
			* type:根据属性数据类型定位属性
		参数第二组：值
			* value:简单的值，字符串
			* ref:复杂的（由spring容器创建的bean对象）
		-->
		<!-- <constructor-arg index="0" value="1"/> -->
		<constructor-arg index="0" name="id" value="1"/>
		<!-- <constructor-arg name="name" value="宝马1代"/> -->
		<constructor-arg name="name" >
			<value>宝马2代</value>
		</constructor-arg>
		<constructor-arg type="java.lang.Double" value="99999d"/>
	</bean>
```

### 5.2setter方法属性注入property

一：创建类 提供属性的set方法

```java
/**
 * 定义人类
 * setter方法属性注入
 * 相当于new Person();
 */
public class Person {
	private Integer id;
	private String name;
	private Car car;
	//必须提供setter属性方法
	public void setId(Integer id) {
		this.id = id;
	}
	public void setName(String name) {
		this.name = name;
	}
	public void setCar(Car car) {
		this.car = car;
	}
	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + ", car=" + car + "]";
	}

}
```

二：配置applicationcontext.xml文件

```xml
<!-- setter方法属性注入:调用默认构造器，相当于new Person() -->
	<bean id="person" class="cn.itcast.spring.e_xmlpropertydi.Person">
		<!-- 
		property：专门进行setter属性注入用的标签 。
			* name:setter方法的属性的名字,例如SetXxx-那么name的属性值为xxx。
			* value:简单的值
			* ref：bean的名字，对象的引用
		-->
		<property name="id" value="1001"/>
		<property name="name" value="Tom"/>
		<!-- <property name="car" ref="car"/> --><!--等同于-->
		<property name="car">
			<ref bean="car"/>
		</property>
	</bean>
```

#### 5.2.1 p名称空间

为简化XML文件的配置，Spring2.5版本开始引入了一个新的p名称空间。简单的说，它的作用是为了简化setter方法属性依赖注入配置的，它不是真正的名称空间。

第一步：applicationcontext.xml配置中引入p名称空间

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:p="http://www.springframework.org/schema/p"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd">
    
</beans>
```

第二步：将<property>子元素简化为元素的属性注入

```xml
<!-- 使用p名称空间简化setter方法属性注入 -->
<!--
p:name：简单数据类型的属性注入
P:car-ref：复杂数据类型（bean）的属性注入
-->
<bean id="person2" class="cn.itcast.spring.e_xmlpropertydi.Person" p:id="1002" p:name="关羽" p:car-ref="car"/>
```

#### 5.2.2 spEL表达式

spEL（Spring Expression Language）是一种表达式语言，它是**spring3.x版本的新特性。** 

它的作用是：支持在运行时操作和查询对象，其语法类似统一的EL语言，但是SpEL提供了额外的功能，功能更强大。

语法： #{…} , 引用另一个Bean 、属性、 方法 , 运算

SpEL表达式的使用功能比较多，Bean操作相关的通常有：

* {beanid} 引用Bean(具体对象)

* {beanId.属性} 引用Bean的属

* {beanId.方法(参数)} 调用Bean的方法 

  案例：配置applicationcontext.xml

  ```xml
  <!-- spEL的使用 -->
  		<!-- #{person.id} 相当于调用了person的getId()方法 -->
  	<bean id="person3" class="cn.itcast.spring.e_xmlpropertydi.Person" 
  	p:id="#{1+1}" p:name="#{person.name.toUpperCase()}" p:car="#{car}"></bean>
  ```


## 6.IOC容器装配Bean基于注解配置方式

### 6.1Bean的注册

xml做法 ： <bean id=”customerService” class=”…” />，用<bean>的方式创建对象

注解做法 ： spring2.5引入 @Component 注解 如果放置到类的上面，相当于在spring容器中定义<bean id=”” class=””>

创建类：CustomerService.java类

```java
/**
 * @Component注解放置到类上
 * 相当于spring容器中定义：<bean id="customerService" class="cn.itcast.spring.a_ioc.CustomerService">
 * 其中id属性默认bean的名字是类名的小写
 * ——————————————————————————————————————————————————————
 * @Component(value="customerService")//自定义bean的名字
 * 相当于spring容器中定义：<bean id="customerService" class="cn.itcast.spring.a_ioc.CustomerService">
 * ——————————————————————————————————————————————————————
 */
@Component("customerService")
public class CustomerService {
	
	//保存业务方法
	public void save(){
		System.out.println("CustomerService业务层被调用了。。。");
	}

}
```

配置注解开启和注解Bean 的扫描

```xml
 <?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       					   http://www.springframework.org/schema/beans/spring-beans.xsd
						   http://www.springframework.org/schema/context 
						   http://www.springframework.org/schema/context/spring-context.xsd">
	<!-- 配置注解扫描 
			context:component-scan:专门扫描含有@Component注解的类，自动将其作为bean
			base-package：要扫描包的路径,包含子包,cn.itcast.spring表示子包下的所有类定义注解都有效
			注解扫描配置的时候，会自动开启注解功能
	-->
	<context:component-scan base-package="cn.itcast.spring"/>
</beans>
```

### 6.2衍射注解

Spring3.0为我们引入了组件自动扫描机制，它可以在类路径底下寻找标注了@Component、@Service、@Controller、@Repository注解的类，并把这些类纳入进spring容器中管理。

除了@Component外，Spring提供了3个功能基本和@Component等效的注解

功能介绍

@Service用于标注业务层组件、（如Service层）

@Controller用于标注控制层组件（如struts中的action层,springMVC中的controller）

@Repository用于标注数据访问组件，（如DAO层组件）。

而@Component	泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。

### 6.3Bean属性依赖注入

#### 6.3.1 @Value

```java
//@Component(value="customerService")
@Service(value="customerService")
public class CustomerService {
	//简单类型的成员变量
	@Value("Rose")//参数的值简单类型
	private String name="Jack";
	//保存业务方法
	public void save(){
		System.out.println("CustomerService业务层被调用了。。。");
		System.out.println("name:"+name);
	}
}
```

#### 6.3.2 @Value("#{bean.id}")

```java
//@Component(value="customer")
@Service(value="customer")
public class CustomerService {
	//简单类型的成员变量
	@Value("Rose")//参数的值简单类型
	private String name="Jack";
	
	//在属性声明上面注入，底层自动还是生成setCustomerDao()
	//第一种： 使用@Value 结合SpEL  ---- spring3.0 后用
    //其中customerDao表示<bean>节点id的属性值
	@Value("#{customerDao}")
	private CustomerDao customerDao;
	
	//保存业务方法
	public void save(){
		System.out.println("CustomerService业务层被调用了。。。");
		System.out.println("name:"+name);
		customerDao.save();
	}

}
```

#### 6.3.3 **@Autowired结合@Qualifier  （常用）**

单独使用@Autowired ，表示按照类型注入，会到spring容器中查找CustomerDao的类型，对应<bean class=””>，class的属性值，如果找到，可以匹配

```java
    //第二种：使用spring的@Autowired
	@Autowired//默认按照类型注入
	private CustomerDao customerDao;
```

使用@Autowired + @ Qualifier 表示按照名称注入，回到spring容器中查找customerDao的名称，对应<bean id=””>，id的属性值，如果找到，可以匹配。

```java
	//第二种：使用spring的@Autowired 结合 @Qualifier
	@Autowired//默认按照类型注入的
	@Qualifier("customerDao")//必须配合@Autowired注解使用，根据名字注入
	private CustomerDao customerDao;
```

#### 6.3.4 @Resource

```java'
    //第三种： JSR-250标准（jdk） 提供@Resource 
    //@Resource   默认先按照名称匹配，再按照类型匹配
	@Resource(name="customerDao")//只能按照customerDao名称进行匹配
	private CustomerDao customerDao;
```





### 6.4 改变作用域范围

#### @Scope

**作用：指定bean的作用范围**

默认singleton  单例模式

```
value：指定范围的值。取值：singleton  prototype request session globalsession
```



### 6.5 生命周期相关

#### @Postconstruct

初始化方法，ioc创建bean对象时调用创建方法相当于Inint—method

```java
  @PostConstruct//指定该方法是一个初始化方法
    public void init(){
        System.out.println("调用了init方法...");
    }
```

![](assets/16.png)

#### @PreDestory

@PreDestory加在方法上，指定bean销毁之前，调用该方法，类似于xml的destory-method方法

```java
    @PreDestroy//指定该方法是一个销毁方法
    public void destroy(){
        System.out.println("调用了destroy方法...");
    }
```

![](assets/17.png)





### 6.6 xml和注解的比较

![18](assets/18.png)



### 6.7 Spring框架整合JUnit单元测试

注解和xml混合的单元测试

```java
@RunWith(SpringJUnit4ClassRunner.class)//指定采用spring的运行器来执行单元测试方法
@ContextConfiguration("classpath:applicationContext.xml")//指定spring配置文件的路径
public class TestIOC {

    @Autowired
    private UserService userService;//要测试的目标，直接注入进来
    /**
     * 测试注解
     */
    @Test
    public void test1() {
        userService.saveUser();
    }
}
```

纯注解工程使用单元测试

````java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)//指定加载配置类
public class TestFind {

    @Autowired
    private CustomerService customerService;

    @Test
    public void test1() {
        List<Customer> list = customerService.findAllCustomer();
        for (Customer customer : list) {
            System.out.println(customer);
        }
    }

}
````



# Spring的AOP编程

## 1.AOP概述

AOP作用：在不修改源码的情况下可是实现功能的增强

AOP应用场景：

场景一： 记录日志 

场景二： 监控方法运行时间 （监控性能）

场景三： 权限控制 

场景四： 缓存优化 （第一次调用查询数据库，将查询结果放入内存对象， 第二次调用， 直接从内存对象返回，不需要查询数据库 ）

场景五： 事务管理 （调用方法前开启事务， 调用方法后提交关闭事务 ）

## 2.AOP相关术语

### Joinpoint(连接点)

指那些被拦截到的点，在spring中，这些点指的是方法，spring只支持方法类型的连接点。

### Pointcut(切入点)

指要对哪些Joinpoint进行拦截的定义

### Advice(通知/增强)

拦截到Pointcut后要做的事情就是通知，通知分为：

**前置通知，后置通知，异常通知，最终通知，环绕通知**

### Introduction(引介)

引介是一种特殊的通知在不修改代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field

### Target(目标对象)

代理的目标对象

### Weaving(织入)

是指把增强应用到目标对象来创建新的代理对象的过程，spring采用动态代理织入，而Aspect采用编译期织入和类装载期织入。

### Proxy(代理)

一个类似被AOP织入增强后，就产生一个结果代理类

### Aspect(切面)

是切入点和通知的结合



## 3.Spring中AOP编程(xml方式)

applicationcontext.xml中配置方式

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop 
        http://www.springframework.org/schema/aop/spring-aop.xsd">
    <bean id="customerDao" class="cn.itcast.dao.impl.CustomerDaoImpl"></bean>
    <bean id="myAspectXml" class="cn.itcast.aspect.MyAspectXml"></bean>
    <!-- AOP配置 -->
    <aop:config>
        <!-- 配置切入点：告诉spring框架哪些方法需要被增强 -->
        <aop:pointcut expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.save(..))" id="pointcut1"/>
        <!-- 
			配置切面：告诉spring框架调用切面类中的哪个方法来增强 
						ref：指定切面类的id
				-->
        <aop:aspect ref="myAspectXml">
          	<!--
								配置通知,before：表示前置通知			
								method：指定切面类中通知方法的名字
								pointcut-ref：指定切入点的id
						-->
            <aop:before method="writeLog" pointcut-ref="pointcut1"/>
        </aop:aspect>
    </aop:config>
</beans>
```



### 3.1 切入点表达式语法

execution(**访问修饰符**|返回类型|空格|包名类名|方法名|(参数)|**异常**)

**访问修饰符**和**异常**，**包名类名**可以不写

```java
execution(public void cn.neu.ServiceImpl.saveUser(java.lang.String))
//共有方法，无返回类型，cn.neu包中的ServiceImpl类中的saveUser方法，一个String类型的参数
 
execution(* cn.neu.ServiceImpl.saveUser(java.lang.String))
//无访问修饰 任意返回值类型 cn.neu包中的ServiceImpl类中的saveUser方法，一个String类型的参数
    
execution(* cn.neu.*.saveUser(java.lang.String))
//无访问修饰 任意返回值类型 cn.neu包中的任意类中的saveUser方法，一个String类型的参数
    
execution(* cn.neu..*.*(java.lang.String，*))
//无访问修饰 任意返回值类型 cn.neu包及其子包下任意类的任意方法，一个String类型的参数，一个任意类型
    
execution(* *..*.*(..))
//返回类型任意，任意包中及其子包中所有类，类中所有方法，参数任意
    
execution(* *Service(..))
//返回类型任意，任意包中及其子包中所有类，类中所有以Service结尾的方法，参数任意
  
```



### 3.2 Spring中AOP的通知类型

#### 前置通知

应用： 权限控制 （权限不足，抛出异常）、 记录方法调用信息日志 

```java
public class MyAspectXml {
    /**
     * 前置通知方法 应用场景： 权限控制 （权限不足，抛出异常）、 记录方法调用信息日志
     * joinPoint:连接点，指的是被增强的那个方法
     */
    public void before(JoinPoint joinPoint) {
        String username = "rose";
        if (!"admin".equals(username)) {
            // 非admin用户，不具备权限，抛出异常
            //joinPoint.getTarget().getClass().getName()获取目标类的名字
            //joinPoint.getSignature().getName()获取被增强方法的名字
            throw new RuntimeException("对不起！您没有对" + joinPoint.getTarget().getClass().getName() + "类中"
                    + joinPoint.getSignature().getName() + "方法的访问权限");
        }
    }
}
```

````xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">
    <bean id="customerDao" class="cn.itcast.dao.impl.CustomerDaoImpl"></bean>
    <!-- 配置切面类 -->
    <bean id="myAspectXml" class="cn.itcast.aspect.MyAspectXml"></bean>

    <aop:config>
        <!-- 配置切入点表达式：告诉spring框架哪些方法需要被增强 -->
        <aop:pointcut expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.save(..))" id="pointcut1"/>
        <aop:aspect ref="myAspectXml">
            <!-- 配置前置通知：告诉spring在目标方法执行之前增强 -->
            <aop:before method="before" pointcut-ref="pointcut1"/>
        </aop:aspect>
    </aop:config>
</beans>
````

![](assets/11.png)

#### 后置通知

特点：在目标方法运行后，返回值后执行增强代码逻辑。

应用场景：与业务相关的，如ATM取款机取款后，自动下发短信。

在CustomerDao接口中增加delete方法，如下： 

```java
public interface CustomerDao {

   void save();

   Integer delete();
}
```

在目标类CustomerDaoImpl中编写目标方法delete方法，需要对该方法增强

```java
public class CustomerDaoImpl implements CustomerDao {

   @Override
   public void save() {
      System.out.println("持久层：客户保存...");
   }

   @Override
   public Integer delete() {
      System.out.println("持久层：客户删除...");
      return 100;
   }
}
```

在切面类MyAspectXml中定义一个后置通知方法afterReturning方法，并添加一个形参result,表示目标方法的返回值： 

```java
/**
 * 自定义切面类
 */
public class MyAspectXml {
    /**
     * 后置通知方法
     * 应用场景： ATM取款机取款后，自动下发短信
     * 参数result:被增强那个方法的返回值，名字要和xml配置的返回值的名字一致
     */
    public void afterReturning(JoinPoint joinPoint,Object result){
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String dateStr = sdf.format(date);
        System.out.println("尊敬的用户，您于" + dateStr + "取款" + result + "元");
    }

}
```

在applicationContext.xml中配置切入点及后后置通知，并指定returning属性的值为result，通知方法的形参的名字要与returning的值一致： 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">
    <bean id="customerDao" class="cn.itcast.dao.impl.CustomerDaoImpl"></bean>
    <!-- 配置切面类 -->
    <bean id="myAspectXml" class="cn.itcast.aspect.MyAspectXml"></bean>

    <aop:config>
        <!-- 配置切入点表达式：告诉spring框架哪些方法需要被增强 -->
        <aop:pointcut expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.save(..))" id="pointcut1"/>
        <aop:pointcut expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.delete(..))" id="pointcut2"/>
        <aop:aspect ref="myAspectXml">
            <!-- 配置前置通知：告诉spring在目标方法执行之前增强 -->
            <aop:before method="before" pointcut-ref="pointcut1"/>
            <!-- 配置后置通知,returning指定目标方法返回值的名字 -->
            <aop:after-returning method="afterReturning" pointcut-ref="pointcut2" returning="result"/>
        </aop:aspect>
    </aop:config>
</beans>
```

修改TestAOP中的test1方法，如下： 

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class TestAOP {

    @Autowired
    private CustomerDao customerDao;

    @Test
    public void test1(){
//        customerDao.save();
        customerDao.delete();
    }
}
```

测试结果如下： 

![12](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/ssm/Spring%E7%AC%AC%E4%B8%89%E5%A4%A9/01-%E7%AC%94%E8%AE%B0/Img/12.png)

#### 环绕通知

特点：目标执行前后，都进行增强（控制目标方法执行）

应用场景：日志、缓存、权限、性能监控、事务管理

增强代码的方法要求：

接受的参数：ProceedingJoinPoint（可执行的连接点）

返回值：Object返回值

抛出Throwable异常。

在CustomerDao接口中增加update方法:

```java
public interface CustomerDao {

   void save();

   Integer delete();

   void update();
}
```

在目标类CustomerDaoImpl中编写目标方法update方法，需要对该方法增强:

```java
public class CustomerDaoImpl implements CustomerDao {

   @Override
   public void save() {
      System.out.println("持久层：客户保存...");
   }

   @Override
   public Integer delete() {
      System.out.println("持久层：客户删除...");
      return 100;
   }

   @Override
   public void update() {
      System.out.println("持久层：客户更新...");
   }

}
```

在切面类MyAspectXml中定义一个环绕通知方法around方法，需要给该方法增加一个形参ProceedingJoinPoint ，表示正在执行的连接点（目标）。

```java
/**
 * 自定义切面类
 */
public class MyAspectXml {


    /**
     * 环绕通知方法
     * 应用场景：事务处理
     * @param proceedingJoinPoint 正在执行的连接点
     * @return
     */
    public Object around(ProceedingJoinPoint proceedingJoinPoint){
        System.out.println("开启事务");
        //获取目标方法的参数
        Object[] args = proceedingJoinPoint.getArgs();
        Object result = null;//目标方法的返回值
        try {
            //调用目标方法，获取目标方法的返回值
            result = proceedingJoinPoint.proceed(args);
            System.out.println("提交事务");
        } catch (Throwable e) {
            System.out.println("回滚事务");
        }
        //返回目标方法的返回值
        return result;
    }

}
```

说明：

ProceedingJoinPoint：表示正在执行的连接点，也就是目标方法

joinpoint.proceed表示调用目标方法

在applicationContext.xml中配置切入点表达式及环绕通知:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">
    <bean id="customerDao" class="cn.itcast.dao.impl.CustomerDaoImpl"></bean>
    <!-- 配置切面类 -->
    <bean id="myAspectXml" class="cn.itcast.aspect.MyAspectXml"></bean>

    <aop:config>
        <!-- 配置切入点表达式：告诉spring框架哪些方法需要被增强 -->
        <aop:pointcut expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.save(..))" id="pointcut1"/>
        <aop:pointcut expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.delete(..))" id="pointcut2"/>
        <aop:pointcut expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.update(..))" id="pointcut3"/>
        <aop:aspect ref="myAspectXml">
            <!-- 配置前置通知：告诉spring在目标方法执行之前增强 -->
            <aop:before method="before" pointcut-ref="pointcut1"/>
            <!-- 配置后置通知 -->
            <aop:after-returning method="afterReturning" pointcut-ref="pointcut2" returning="result"/>
            <!-- 配置环绕通知 -->
            <aop:around method="around" pointcut-ref="pointcut3"/>
        </aop:aspect>
    </aop:config>

</beans>
```

修改TestAOP中的test1方法： 

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class TestAOP {

    @Autowired
    private CustomerDao customerDao;

    @Test
    public void test1(){
//        customerDao.save();
//        customerDao.delete();
        customerDao.update();
    }
}
```

测试结果如下图： 

![13](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/ssm/Spring%E7%AC%AC%E4%B8%89%E5%A4%A9/01-%E7%AC%94%E8%AE%B0/Img/13.png)

#### 异常抛出通知

作用：目标代码出现异常，通知执行。记录异常日志、通知管理员（短信、邮件）

应用场景：处理异常（一般不可预知），记录日志

在CustomerDao接口中增加list方法： 

```java
public interface CustomerDao {

   void save();

   Integer delete();

   void update();

   void list();
}
```

在目标类CustomerDaoImpl中编写目标方法list方法，需要对该方法增强:

```java
public class CustomerDaoImpl implements CustomerDao {

   @Override
   public void save() {
      System.out.println("持久层：客户保存...");
   }

   @Override
   public Integer delete() {
      System.out.println("持久层：客户删除...");
      return 100;
   }

   @Override
   public void update() {
      System.out.println("持久层：客户更新...");
   }

   @Override
   public void list() {
      System.out.println("持久层：客户查询...");
      //自己造一个异常
      int i = 10 / 0;
   }
}
```

在切面类MyAspectXml中定义一个异常通知方法afterThrowing方法，在方法加一个异常参数，名字叫ex 

```java
/**
 * 自定义切面类
 */
public class MyAspectXml {

    /**
     * 异常通知方法
     * 应用场景：处理异常
     * @param ex 目标方法抛出的异常，名字要与配置文件中配置的名字一致
     */
    public void afterThrowing(JoinPoint joinPoint, Throwable ex) {
        System.out.println("注意了:在" + joinPoint.getTarget().getClass().getName() + "中的"
                + joinPoint.getSignature().getName() + "方法中发生了异常：" + ex.getMessage());
    }

}
```

在applicationContext.xml中配置切入点表达式及异常通知，需要给异常通知指定throwing属性，表示异常的名字，异常通知方法的形参名字要与此处一致： 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">
    <bean id="customerDao" class="cn.itcast.dao.impl.CustomerDaoImpl"></bean>
    <!-- 配置切面类 -->
    <bean id="myAspectXml" class="cn.itcast.aspect.MyAspectXml"></bean>

    <aop:config>
        <!-- 配置切入点表达式：告诉spring框架哪些方法需要被增强 -->
        <aop:pointcut expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.save(..))" id="pointcut1"/>
        <aop:pointcut expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.delete(..))" id="pointcut2"/>
        <aop:pointcut expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.update(..))" id="pointcut3"/>
        <aop:pointcut expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.list(..))" id="pointcut4"/>
        <aop:aspect ref="myAspectXml">
            <!-- 配置前置通知：告诉spring在目标方法执行之前增强 -->
            <aop:before method="before" pointcut-ref="pointcut1"/>
            <!-- 配置后置通知 -->
            <aop:after-returning method="afterReturning" pointcut-ref="pointcut2" returning="result"/>
            <!-- 配置环绕通知 -->
            <aop:around method="around" pointcut-ref="pointcut3"/>
            <!-- 配置异常通知，throwing：指定目标方法异常的名字 -->
            <aop:after-throwing method="afterThrowing" pointcut-ref="pointcut4" throwing="ex"/>
        </aop:aspect>
    </aop:config>

</beans>
```

修改TestAOP中的test1方法： 

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:applicationContext.xml")
public class TestAOP {

    @Autowired
    private CustomerDao customerDao;

    @Test
    public void test1() {
//        customerDao.save();
//        customerDao.delete();
//        customerDao.update();
        customerDao.list();
    }
}
```

测试结果如下： 

![14](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/ssm/Spring%E7%AC%AC%E4%B8%89%E5%A4%A9/01-%E7%AC%94%E8%AE%B0/Img/14.png)

#### 最终通知

作用：不管目标方法是否发生异常，最终通知都会执行（类似于finally代码功能）

应用场景：释放资源 （关闭文件、 关闭数据库连接、 网络连接、 释放内存对象 ）

在切面类MyAspect中定义一个最终通知方法after方法：

```java
/**
 * 自定义切面类
 */
public class MyAspectXml {
    /**
     * 前置通知方法 应用场景： 权限控制 （权限不足，抛出异常）、 记录方法调用信息日志
     * joinPoint:连接点，指的是被增强的那个方法
     */
    public void before(JoinPoint joinPoint) {
        String username = "rose";
        if (!"admin".equals(username)) {
            // 非admin用户，不具备权限，抛出异常
            //joinPoint.getTarget().getClass().getName()获取目标类的名字
            //joinPoint.getSignature().getName()获取被增强方法的名字
            throw new RuntimeException("对不起！您没有对" + joinPoint.getTarget().getClass().getName() + "类中"
                    + joinPoint.getSignature().getName() + "方法的访问权限");
        }
    }


    /**
     * 后置通知方法
     * 应用场景： ATM取款机取款后，自动下发短信
     * 参数result:被增强那个方法的返回值
     */
    public void afterReturning(JoinPoint joinPoint,Object result){
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String dateStr = sdf.format(date);
        System.out.println("尊敬的用户，您于" + dateStr + "取款" + result + "元");
    }

    /**
     * 环绕通知方法
     * 应用场景：事务处理
     * @param proceedingJoinPoint 正在执行的连接点
     * @return
     */
    public Object around(ProceedingJoinPoint proceedingJoinPoint){
        System.out.println("开启事务");
        //获取目标方法的参数
        Object[] args = proceedingJoinPoint.getArgs();
        Object result = null;
        try {
            //调用目标方法，获取目标方法的返回值
            result = proceedingJoinPoint.proceed(args);
            System.out.println("提交事务");
        } catch (Throwable e) {
            System.out.println("回滚事务");
        }
        //返回目标方法的返回值
        return result;
    }

    /**
     * 异常通知方法
     * 应用场景：处理异常
     * @param ex 目标方法抛出的异常，名字要与配置文件中配置的名字一致
     */
    public void afterThrowing(JoinPoint joinPoint, Throwable ex) {
        System.out.println("注意了:在" + joinPoint.getTarget().getClass().getName() + "中的"
                + joinPoint.getSignature().getName() + "方法中发生了异常：" + ex.getMessage());
    }

    /**
     * 最终通知方法 应用场景：释放资源 （关闭文件、 关闭数据库连接、 网络连接、 释放内存对象 ）
     *
     * @param joinPoint
     *            被增强的那个方法
     */
    public void after(JoinPoint joinPoint) {
        System.out.println("开始释放资源，对应的连接点信息为：" + joinPoint.getTarget().getClass().getName() + "的"
                + joinPoint.getSignature().getName() + "方法");
    }

}
```

在applicationContext.xml中配置最终通知：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">
    <bean id="customerDao" class="cn.itcast.dao.impl.CustomerDaoImpl"></bean>
    <bean id="myAspectXml" class="cn.itcast.aspect.MyAspectXml"></bean>
    <!-- AOP配置 -->
    <aop:config>
        <!-- 配置切入点 -->
        <aop:pointcut
                expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.save(..))"
                id="pointcut1" />
        <aop:pointcut
                expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.delete(..))"
                id="pointcut2" />
        <aop:pointcut
                expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.update(..))"
                id="pointcut3" />
        <aop:pointcut
                expression="execution(* cn.itcast.dao.impl.CustomerDaoImpl.list(..))"
                id="pointcut4" />
        <!-- 配置切面 -->
        <aop:aspect ref="myAspectXml">
            <!-- 前置通知 -->
            <aop:before method="before" pointcut-ref="pointcut1" />
            <!-- 后置通知 -->
            <aop:after-returning method="afterReturning"
                                 pointcut-ref="pointcut2" returning="result" />
            <!-- 环绕通知 -->
            <aop:around method="around" pointcut-ref="pointcut3" />
            <!-- 抛出异常通知 -->
            <aop:after-throwing method="afterThrowing"
                                pointcut-ref="pointcut4" throwing="ex" />
            <!-- 最终通知 -->
            <aop:after method="after" pointcut-ref="pointcut4" />
        </aop:aspect>
    </aop:config>

</beans>
```

再次运行TestAOP中的test1方法，结果如下： 

![15](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/ssm/Spring%E7%AC%AC%E4%B8%89%E5%A4%A9/01-%E7%AC%94%E8%AE%B0/Img/15.png)

把CustomerDaoImpl中的list方法中的异常注释掉，再次运行TestAOP中的test1方法： 

```java
public class CustomerDaoImpl implements CustomerDao {

   @Override
   public void save() {
      System.out.println("持久层：客户保存...");
   }

   @Override
   public Integer delete() {
      System.out.println("持久层：客户删除...");
      return 100;
   }

   @Override
   public void update() {
      System.out.println("持久层：客户更新...");
   }

   @Override
   public void list() {
      System.out.println("持久层：客户查询...");
      //自己造一个异常
//    int i = 10 / 0;
   }
}
```

测试结果如下：发现没有执行异常通知，但是依然执行了最终通知：

![16](D:/%E4%B8%8A%E8%AF%BE%E8%A7%86%E9%A2%91/15%E6%9C%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/ssm/Spring%E7%AC%AC%E4%B8%89%E5%A4%A9/01-%E7%AC%94%E8%AE%B0/Img/16.png)

注意，最终通知和后置通知的区别：最终通知，不管异常与否，都执行；而后置通知在异常时不执行。

## 4.Spring中AOP编程(注解方式)

applicationcontext.xml配置

~~~xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    <!-- 开启spring注解扫描 -->
    <context:component-scan base-package="cn.neu"></context:component-scan>
    <!-- 开启aspectj自动代理 -->
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>

</beans>
~~~

### 4.1编写切面类@Aspect

### 4.2通知类型的注解

#### 1.@Before(前置通知)

```java
/**
 * 切面类
 */
@Component
@Aspect//表示该类是一个切面类
public class MyAspectAnnotation {

    /*@Before("execution(* cn.itcast.dao.impl.CustomerDaoImpl.save(..))")
   public void writeLog(){
      System.out.println("记录日志啦.....");
   }*/


    /**
     * 前置通知方法 应用场景： 权限控制 （权限不足，抛出异常）、 记录方法调用信息日志 joinPoint:连接点，指的是被增强的那个方法
     */
    @Before("execution(* cn.itcast.dao.impl.CustomerDaoImpl.save(..))")
    public void before(JoinPoint joinPoint) {
        String username = "rose";
        if (!"admin".equals(username)) {
            // 非admin用户，不具备权限，抛出异常
            // joinPoint.getTarget().getClass().getName()获取目标类的名字
            // joinPoint.getSignature().getName()获取被增强方法的名字
            throw new RuntimeException("对不起！您没有对" + joinPoint.getTarget().getClass().getName() + "类中"
                    + joinPoint.getSignature().getName() + "方法的访问权限");
        }
    }
}
```



#### 2.@AfterReturning(后置通知)

修改MyAspectAnnotation，在其中创建后置通知方法afterReturning，在该方法上添加@AfterReturning注解，通过value属性指定切入点表达式，returning属性指定返回值的名字，该方法形参的名字要与returning的值一致： 

```java
/**
 * 切面类
 */
@Component
@Aspect//表示该类是一个切面类
public class MyAspectAnnotation {

    /**
     * 后置通知方法 应用场景： ATM取款机取款后，自动下发短信 参数result:被增强那个方法的返回值
     * returning属性指定目标方法返回值的名字
     */
    @AfterReturning(value="execution(* cn.itcast.dao.impl.CustomerDaoImpl.delete(..))",returning="result")
    public void afterReturning(JoinPoint joinPoint, Object result) {
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String dateStr = sdf.format(date);
        System.out.println("尊敬的用户，您于" + dateStr + "取款" + result + "元");
    }

}
```

#### 3.@Around(环绕通知)

```java
/**
 * 切面类
 */
@Component
@Aspect//表示该类是一个切面类
public class MyAspectAnnotation {

    /**
     * 环绕通知方法 应用场景：事务处理
     *
     * @param proceedingJoinPoint
     *            正在执行的连接点
     * @return
     */
    @Around("execution(* cn.itcast.dao.impl.CustomerDaoImpl.update(..))")
    public Object around(ProceedingJoinPoint proceedingJoinPoint) {
        System.out.println("开启事务");
        // 获取目标方法的参数
        Object[] args = proceedingJoinPoint.getArgs();
        Object result = null;
        try {
            // 调用目标方法，获取目标方法的返回值
            result = proceedingJoinPoint.proceed(args);
            System.out.println("提交事务");
        } catch (Throwable e) {
            System.out.println("回滚事务");
        }
        // 返回目标方法的返回值
        return result;
    }
}
```

#### 4.@AfterThrowing(异常通知)

```java
 @AfterThrowing(value="execution表达式",throwing="ex")
```

```java
/**
 * 切面类
 */
@Component
@Aspect//表示该类是一个切面类
public class MyAspectAnnotation {

    /**
     * 异常通知方法 应用场景：处理异常
     *
     * @param ex
     *            目标方法抛出的异常
     */
    @AfterThrowing(value="execution(* cn.dao.impl.CusImpl.list(..))",throwing="ex")
    public void afterThrowing(JoinPoint joinPoint, Throwable ex) {
        System.out.println("注意了:在" + joinPoint.getTarget().getClass().getName() + "中的"
                + joinPoint.getSignature().getName() + "方法中发生了异常：" + ex.getMessage());
    }

}
```

#### 5.@After(最终通知)

```java
/**
 * 切面类
 */
@Component
@Aspect//表示该类是一个切面类
public class MyAspectAnnotation {

    /**
     * 最终通知方法 应用场景：释放资源 （关闭文件、 关闭数据库连接、 网络连接、 释放内存对象 ）
     *
     * @param joinPoint
     *            被增强的那个方法
     */
    @After("execution(* cn.itcast.dao.impl.CustomerDaoImpl.list(..))")
    public void after(JoinPoint joinPoint) {
        System.out.println("开始释放资源，对应的连接点信息为：" + joinPoint.getTarget().getClass().getName() + "的"
                + joinPoint.getSignature().getName() + "方法");
    }

}
```



# Spring的事务控制

## 1.事务相关

### 1.1事务的特性

* 原子性
* 一致性
* 持久性
* 隔离性

### 1.2事务并发引起的一些读问题

* 脏读
* 不可重复读
* 虚读，幻读

### 1.3事务隔离的四个级别

* read uncommitted
* read committed
* repeatable read
* serializable



## 2.事务的传播行为

required:如果当前没有事务，就新建一个事务。如果当前有事务，就加入到当前事务中(用得最多，默认值)

required_new:新建事务，如果当前有事务就把当前事务挂起

supports:支持事务，如果当前没有事务就以非事务运行(没有事务)

mandatory:使用当前事务，如果当前没有事务就抛出异常

not_supports:以非事务方式运行，如果当前有事务，就把当前事务挂起

never:以非事务方式运行，如果当前有事务就抛出异常

nested:如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则执行required类似的操作

## 3.在xml中配置事务

~~~xml
   
<!-- 配置事务管理器 -->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
 <!-- 注入数据源 -->
  <property name="dataSource" ref="dataSource"></property>
</bean>

<!-- 配置事务属性 -->
<tx:advice id="txAdvice" transaction-manager="transactionManager">
  	<tx:attributes>
        <!-- find开头的方法加只读事务 ，*表示通配符，匹配任意方法-->
        <tx:method name="find*" read-only="true"/>
        <!-- 其余方法是加可读写的事务 -->
        <tx:method name="*"/>
  	</tx:attributes>
 </tx:advice>  

<!-- 配置事务切面 -->
<aop:config>
  	<!-- 配置切入点表达式：告诉框架哪些方法要控制事务 -->
  	<aop:pointcut expression="execution(* cn.itcast.impl.*.*(..))" id="pt"/>
    <!--将定义好的事务属性应用到上述的切入点 -->
  	<aop:advisor advice-ref="txAdvice" pointcut-ref="pt"/>
</aop:config>

~~~



## 4.用注解配置事务

### 4.1applicationcontext.xml配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd">
         <!-- 开启spring注解扫描 -->
		 <context:component-scan base-package="cn.itcast"></context:component-scan>
    
        <context:property-placeholder location="classpath:jdbc.properties"/>
    	<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
				<property name="driverClassName" value="${jdbc.driverClass}"></property>
				<property name="url" value="${jdbc.url}"></property>
				<property name="username" value="${jdbc.username}"></property>
				<property name="password" value="${jdbc.password}"></property>
	   </bean>
    
        <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
   	 		<property name="dataSource" ref="dataSource"></property>
   	 	</bean>
    
           <!-- 开启事务注解的支持
		      transaction-manager:写事务管理器的id
	    -->      
 		 <tx:annotation-driven transaction-manager="transactionManager"/>
        
        <!-- 配置事务管理器 -->
        <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        	<property name="dataSource" ref="dataSource"></property>
		</bean>
```



### 4.2业务层上加注解

```java
@Service("accountService")
@Transactional//该类中所有的方法都加可读写的事务
public class AccountServiceImpl implements AccountService{
	
	@Autowired
	private AccountDao accountDao;
	@Override
	public void transfer(Long fromId, Long toId, Double money) {
		//查询转出账户
		Account fromAccount = accountDao.findById(fromId);
		//查询转入账户
		Account toAccount = accountDao.findById(toId);
		//转出账户减钱
		fromAccount.setMoney(fromAccount.getMoney() - money);
		//转入账户加钱
		toAccount.setMoney(toAccount.getMoney() + money);
		//更新转出账户
		accountDao.update(fromAccount);
		int i = 10 / 0;
		//更新转入账户
		accountDao.update(toAccount);
	}

	@Override
    //如果Transactional注解如果加在方法上则以方法上为准
	@Transactional(readOnly=true)//只读事务
	public void findById(Long id) {
		Account fromAccount = accountDao.findById(id);
		fromAccount.setMoney(10000D);
		accountDao.update(fromAccount);
	}

}

```



# Spring中的核心监听器(web)

## 1.概念

ContextLoaderListener是Spring中的核心监听器，当web工程启动时，监听器负责创建IOC容器，存在的servletContext中。需要用到IOC容器时就从ServletContext中获取



## 2.web.xml中配置核心监听器

```xml
 <?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
           version="2.5">
    <!-- 指定spring核心配置文件路径 -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>
    <!-- 配置监听器，当工程启动时，创建ioc容器，存放在ServletContext中 -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
</web-app>

```

## 3.Servlet中获取IOC容器

```java
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //从ServletContext中获取唯一的IOC容器
        ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());
        //从IOC容器中获取AccountService
        AccountService accountService = (AccountService) ac.getBean("accountService");
        List<Account> accounts = accountService.findAllAccount();
        request.setAttribute("accounts", accounts);
        request.getRequestDispatcher("/accounts.jsp").forward(request, response);
    }
}
```



# Hive基本操作

## 1.DDL操作

### 1.1  创建表

~~~
create [external] table [if not exists] tb_name (...) [like] existing_table;
[row format delimited fields terminated by char
					collection items terminated by char
					map keys terminated by char
					lines terminated by char
					...]
[partitioned by ]
[stored as file_format]
[CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]
[LOCATION hdfs_path]

~~~



1.create table 创建一个指定名字的表，如果表以存在可以用[if not exists]跳过异常

2.[external] 关键字可以让给用户创建一个外部表。

创建内部表时会将数据移动到数据仓库指向的路径，删除表时元数据和数据都被删除。

外部表仅记录数据所在的路径，删除时只删除元数据，不删除数据。

3.[like] 允许用户复制现有的表结构，但是不复制数据

4.[row format delimited] 指定表列与列的分隔符。hive建表的时候默认分隔符是‘\001’,

5.[partitioned by] 分区命令。每个表可以有多个分区，每个分区以文件夹的形式单独存在表文件夹目录下。分区是以字段的形式在表结构中存在。

6.[stored as sequencedile|textfile|refile]   如果文件数据是纯文本，可以使用textfile,如果数据需要压缩，使用sequencedile。

textfile是默认的文件格式，使用delimited子句来读取分隔文件

7.[clustered by (col_name,col_name,....)]   分桶

8.[LOCATION hdfs_path]  指定这张表所在的hdfs上的目录，如果不指定，默认在数据库的目录下面

~~~
create table tb_name as select statement;将sql语句的结果进行保存
create table tb_new like tb_old;创建一张结构与tb_old一样的表
drop table [if exists] tb_name;删除表
truncate table tb_name;清空表
show functions;查看所有的函数
show partitions tb_name;查看所有分区
desc formatted tb_name；查看表信息
~~~

#### 1.1.1 管理表

最普通的表，默认表的类型就是管理表

~~~
create table tb_name();
~~~

#### 1.1.2 外部表

~~~
create external table tb_name();
~~~

特点：在删除时，不会删除表数据

应用场景：1-如果需要多张表共用同一份数据，都建立外部表，使用完以后，删除表互不影响。2-如果数据需要进行额外的使用：存档等等

#### 1.1.3 分区表

~~~
create external table tb_part(
id string
 name string
)
partitioned by (day string)
row format delimited fields terminated by '\t';
--创建分区表，指定分区字段day
load data local inpath '/export/datas/20180718' into table tb_name partition(day='18');
--加载文件数据，创建分区字段day=18
load data local inpath '/export/datas/20180719' into table tb_name partition(day='19');
load data local inpath '/export/datas/1234.txt' into table student_imformation;
--加载文件数据，创建分区字段day=19
select * from tb_part where day = 19;
--过滤条件需是分区的字段，如果不是分区字段就会从整个分区目录中查找
~~~

* **手动分区**：加载数据时，手动指定文件的分区

  ~~~
  insert overwrite table tb_emp_part partition (deptno)
    select empno
    ename,
    job,
    manager,
    inday,
    salary,
    jiangjin,
    deptno
  from tb_emp_normal;
  ~~~

  应用场景：将普通表的数据转换成一个分区表
  		   原始表【tb1】中的数据没有做分区
  		   希望将原始表中的数据按照分区存放到新的分区表[tb2]

* **自动分区**：默认按照原始表的最后一列进行分区

~~~
set hive.exec.dynamic.partition.mode=nonstrict;
配置自动分区
show partitions tb_name;
查看当前所有分区
~~~

**数据加载问题：**
1-如果手动将数据文件放入一张普通表的目录下？表能不能读到数据？

​	可以，元数据查询时直接将表的目录作为查询目录
2-如果手动将数据文件放入一张分区表的分区目录下？表能不能读到数据？/表的分区能不能读到数据？
	可以的，因为元数据查询时直接将分区的目录作为查询目录
3-如果手动在HDFS上创建一个分区的目录，将数据放入分区目录下，表能不能读到数据？
	不能，因为Hive中没有该分区的元数据

方案一：修复表的元数据（资源占用多）

~~~
msck repair table tb_emp;
~~~

方案二：手动向表中添加一个分区

~~~
alter table tb_name add [if exists] partition (dt='20') location '/user/hadoop/dt=20';
--要求建立的目录必须与分区自动创建的目录格式一样
~~~

#### 1.1.4  分桶表

~~~
create table tb_emp_bucket(
empno int ,
ename string,
job string,
manager int,
inday string,
salary double,
jiangjin double,
deptno int
) 
clustered by (deptno) into 3 BUCKETS
row format delimited fields terminated by '\t';
~~~

应用场景：大表join大表时

~~~
--开启分桶
set hive.enforce.bucketing=true;

insert overwrite table tb_emp_bucket
select * from tb_emp_normal cluster by (deptno);
~~~

连个桶表桶的个数必须相同，或者b表桶是a表的倍数

### 1.2 修改表

增加分区：

~~~
alter table tb_name add partition (dt='20170101') location '/user/hadoop/table_name/dt=20170101';
~~~

删除分区

~~~
alter table tb_name drop if exists partition (dt='20170101')
~~~

修改分区

~~~
alter table tb_name partition (dt='20170101') rename to partition(dt='20170202')
~~~

添加列

~~~
alter table tb_name add|replace columns (col_name string);
~~~



## 2.DML操作

### 2.1 load

在将数据加载到表中时，Hive不会进行任何转换。加载操作是将数据文件移动到与Hive表对应的位置的纯复制/移动操作。

~~~
load data [local] inpath 'filepath' [overwrite] into table tb_name [partition(partcol1=val1,partcol2=val2...)]
~~~

### 2.2 insert

Hive中insert主要是结合select查询语句使用，将查询结果插入到表中

~~~
insert overwrite table tb_name select statement
**查询结果的列数要和插入数据表格的列数一致
~~~

### 2.3 join

inner join: 两张表都有结果才有

left join: 左表有，结果就有

right join: 右表有，结果就有

full join：两边任意一边有，结果就有

cross join:笛卡尔积      --一般用于结果的漏斗计算

### 2.4 排序

~~~
set hive.exec.reducers.bytes.per.reducer=<number>
	每个reduce最多处理多少数据量
set hive.exec.reducers.max=<number>	
	最多启动多少个reduce
set mapreduce.job.reduces=<number>
	设置reduce的个数
~~~

#### order by

全局排序，对整体进行排序，只有一个reduce的情况下

~~~
select  empno,ename,salary,deptno from tb_emp_normal order by empno;
~~~

#### sort by

局部排序，多个reduce的 情况下，每个reduce内部有序

~~~
set mapreduce.job.reduces=3;
设置reduce个数
insert overwrite local directory '/export/datas/sort' 
row format delimited fields terminated by '\t' 
select  empno,ename,salary,deptno from tb_emp_normal 
sort by empno;
~~~

#### distribute by

指定多个reduce情况下，以哪一列作为分区字段。将相同的数据放入同一个结果文件

~~~
insert overwrite local directory '/export/datas/dis' 
row format delimited fields terminated by '\t' 
select  empno,ename,salary,deptno from tb_emp_normal 
distribute by deptno 
sort by empno;
~~~

#### cluster by

如果sort by与distribute by使用同一个字段可以用此代替



## 3.hive参数配置

### 3.1 Hive **shell命令行**

针对bin/hive，除了可以当第一代客户端之外。还可以在hive中启动其他用途。

1、 -i  初始化HQL文件。

2、 -e从命令行执行指定的HQL 

3、 -f 执行HQL脚本 

4、 -v 输出执行的HQL语句到控制台 

5、 -p <port> connect to Hive Server on port number 

6、 -hiveconf x=y Use this to set hive/hadoop configuration variables.

例如：

$HIVE_HOME/bin/hive -e 'select * from table a'	

$HIVE_HOME/bin/hive -f /home/my/hive-script.sql

$HIVE_HOME/bin/hive -f hdfs://<namenode>:<port>/hive-script.sql

$HIVE_HOME/bin/hive -i /home/my/hive-init.sql

### 3.2 **Hive** **参数配置方式**

*Hive参数大全：*

[*https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties*](https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties)

 开发Hive应用时，不可避免地需要设定Hive的参数。设定Hive的参数可以调优HQL代码的执行效率，或帮助定位问题。然而实践中经常遇到的一个问题是，为什么设定的参数没有起作用？这通常是错误的设定方式导致的。

对于一般参数，有以下三种设定方式：

**配置文件**   （全局有效）

**命令行参数**   （对hive启动实例有效）

**参数声明**   （对hive的连接session有效）

**配置文件** 

用户自定义配置文件：$HIVE_CONF_DIR/hive-site.xml

默认配置文件：$HIVE_CONF_DIR/hive-default.xml 

用户自定义配置会覆盖默认配置。

另外，Hive也会读入Hadoop的配置，因为Hive是作为Hadoop的客户端启动的，Hive的配置会覆盖Hadoop的配置。

配置文件的设定对本机启动的所有Hive进程都有效。

 **命令行参数**

启动Hive（客户端或Server方式）时，可以在命令行添加-hiveconf来设定参数	例如：bin/hive -hiveconf hive.root.logger=INFO,console

设定对本次启动的Session（对于Server方式启动，则是所有请求的Sessions）有效。

 **参数声明**

可以在HQL中使用SET关键字设定参数，这一设定的作用域也是session级的。

比如：

set hive.exec.reducers.bytes.per.reducer=<number>  每个reduce task的平均负载数据量

set hive.exec.reducers.max=<number>   设置reduce task数量的上限

set mapreduce.job.reduces=<number>    指定固定的reduce task数量

但是，这个参数在必要时<业务逻辑决定只能用一个reduce task> hive会忽略

上述三种设定方式的优先级依次递增。即参数声明覆盖命令行参数，命令行参数覆盖配置文件设定。注意某些系统级的参数，例如log4j相关的设定，必须用前两种方式设定，因为那些参数的读取在Session建立以前已经完成了。



## 4.Hive函数

### 4.1自定义函数

#### 4.1.1 UDF

UDF（User-Defined-Function）普通函数 一进一出

1、自定义一个类，继承UDF,实现一个或重载多个evaluate方法，打包上传jar包到linux环境

~~~xml
       <!-- 指定该项目可以从哪些地方下载依赖包 -->
			<repository>
				<id>aliyun</id>
				<url>http://maven.aliyun.com/nexus/content/groups/public/</url>
			</repository>
			<repository>
				<id>cloudera</id>
				<url>https://repository.cloudera.com/artifactory/cloudera-repos/</url>
			</repository>
			<repository>
				<id>jboss</id>
				<url>http://repository.jboss.org/nexus/content/groups/public</url>
			</repository>
		</repositories>
		<!--指定字符编码-->
		<properties>
			<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		</properties>
		<!--指定依赖-->
		<dependencies>
			<dependency>
				<groupId>org.apache.hadoop</groupId>
				<artifactId>hadoop-common</artifactId>
				<version>2.6.0-cdh5.14.0</version>
			</dependency>
			<dependency>
				<groupId>org.apache.hadoop</groupId>
				<artifactId>hadoop-hdfs</artifactId>
				<version>2.6.0-cdh5.14.0</version>
			</dependency>

			<dependency>
				<groupId>org.apache.hadoop</groupId>
				<artifactId>hadoop-client</artifactId>
				<version>2.6.0-cdh5.14.0</version>
			</dependency>
			<dependency>
				<groupId>org.apache.hive</groupId>
				<artifactId>hive-exec</artifactId>
				<version>1.1.0-cdh5.14.0</version>
			</dependency>
			<dependency>
				<groupId>org.apache.hive</groupId>
				<artifactId>hive-common</artifactId>
				<version>1.1.0-cdh5.14.0</version>
			</dependency>
			<dependency>
				<groupId>org.apache.hive</groupId>
				<artifactId>hive-cli</artifactId>
				<version>1.1.0-cdh5.14.0</version>
			</dependency>
			<dependency>
				<groupId>org.apache.hive</groupId>
				<artifactId>hive-jdbc</artifactId>
				<version>1.1.0-cdh5.14.0</version>
			</dependency>
		</dependencies>
~~~

2、将jar包添加到hive环境中

~~~
add jar /export/datas/udf.jar;
~~~

3、在hive中创建一个函数

~~~
create temporary function fc_name as 'com.neusoft.data.UserUDF';
~~~

4、使用函数

~~~
select UserUDF(age),name from tb_name;
~~~

#### 4.1.2 UDAF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

UDAF（User-Defined Aggregation Function）聚合函数，多进一出

UDTF（User-Defined Table-Generating Functions）表生成函数 一进多出

### 















































